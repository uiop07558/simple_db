// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: definition.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_definition_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_definition_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_definition_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_definition_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_definition_2eproto;
namespace objectstore {
class CommitTransactionRequest;
struct CommitTransactionRequestDefaultTypeInternal;
extern CommitTransactionRequestDefaultTypeInternal _CommitTransactionRequest_default_instance_;
class CommitTransactionResponse;
struct CommitTransactionResponseDefaultTypeInternal;
extern CommitTransactionResponseDefaultTypeInternal _CommitTransactionResponse_default_instance_;
class CreateTableRequest;
struct CreateTableRequestDefaultTypeInternal;
extern CreateTableRequestDefaultTypeInternal _CreateTableRequest_default_instance_;
class CreateTableResponse;
struct CreateTableResponseDefaultTypeInternal;
extern CreateTableResponseDefaultTypeInternal _CreateTableResponse_default_instance_;
class DeleteRowRequest;
struct DeleteRowRequestDefaultTypeInternal;
extern DeleteRowRequestDefaultTypeInternal _DeleteRowRequest_default_instance_;
class DeleteRowResponse;
struct DeleteRowResponseDefaultTypeInternal;
extern DeleteRowResponseDefaultTypeInternal _DeleteRowResponse_default_instance_;
class ErrorResponse;
struct ErrorResponseDefaultTypeInternal;
extern ErrorResponseDefaultTypeInternal _ErrorResponse_default_instance_;
class Field;
struct FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class FieldData;
struct FieldDataDefaultTypeInternal;
extern FieldDataDefaultTypeInternal _FieldData_default_instance_;
class FieldDef;
struct FieldDefDefaultTypeInternal;
extern FieldDefDefaultTypeInternal _FieldDef_default_instance_;
class GetTableInfoRequest;
struct GetTableInfoRequestDefaultTypeInternal;
extern GetTableInfoRequestDefaultTypeInternal _GetTableInfoRequest_default_instance_;
class GetTableInfoResponse;
struct GetTableInfoResponseDefaultTypeInternal;
extern GetTableInfoResponseDefaultTypeInternal _GetTableInfoResponse_default_instance_;
class InsertRowRequest;
struct InsertRowRequestDefaultTypeInternal;
extern InsertRowRequestDefaultTypeInternal _InsertRowRequest_default_instance_;
class InsertRowResponse;
struct InsertRowResponseDefaultTypeInternal;
extern InsertRowResponseDefaultTypeInternal _InsertRowResponse_default_instance_;
class QueryRowResponse;
struct QueryRowResponseDefaultTypeInternal;
extern QueryRowResponseDefaultTypeInternal _QueryRowResponse_default_instance_;
class QueryRowsRequest;
struct QueryRowsRequestDefaultTypeInternal;
extern QueryRowsRequestDefaultTypeInternal _QueryRowsRequest_default_instance_;
class RollbackTransactionRequest;
struct RollbackTransactionRequestDefaultTypeInternal;
extern RollbackTransactionRequestDefaultTypeInternal _RollbackTransactionRequest_default_instance_;
class RollbackTransactionResponse;
struct RollbackTransactionResponseDefaultTypeInternal;
extern RollbackTransactionResponseDefaultTypeInternal _RollbackTransactionResponse_default_instance_;
class StartTransactionRequest;
struct StartTransactionRequestDefaultTypeInternal;
extern StartTransactionRequestDefaultTypeInternal _StartTransactionRequest_default_instance_;
class StartTransactionResponse;
struct StartTransactionResponseDefaultTypeInternal;
extern StartTransactionResponseDefaultTypeInternal _StartTransactionResponse_default_instance_;
class TransactionRequest;
struct TransactionRequestDefaultTypeInternal;
extern TransactionRequestDefaultTypeInternal _TransactionRequest_default_instance_;
class TransactionResponse;
struct TransactionResponseDefaultTypeInternal;
extern TransactionResponseDefaultTypeInternal _TransactionResponse_default_instance_;
class UpdateRowRequest;
struct UpdateRowRequestDefaultTypeInternal;
extern UpdateRowRequestDefaultTypeInternal _UpdateRowRequest_default_instance_;
class UpdateRowResponse;
struct UpdateRowResponseDefaultTypeInternal;
extern UpdateRowResponseDefaultTypeInternal _UpdateRowResponse_default_instance_;
}  // namespace objectstore
PROTOBUF_NAMESPACE_OPEN
template<> ::objectstore::CommitTransactionRequest* Arena::CreateMaybeMessage<::objectstore::CommitTransactionRequest>(Arena*);
template<> ::objectstore::CommitTransactionResponse* Arena::CreateMaybeMessage<::objectstore::CommitTransactionResponse>(Arena*);
template<> ::objectstore::CreateTableRequest* Arena::CreateMaybeMessage<::objectstore::CreateTableRequest>(Arena*);
template<> ::objectstore::CreateTableResponse* Arena::CreateMaybeMessage<::objectstore::CreateTableResponse>(Arena*);
template<> ::objectstore::DeleteRowRequest* Arena::CreateMaybeMessage<::objectstore::DeleteRowRequest>(Arena*);
template<> ::objectstore::DeleteRowResponse* Arena::CreateMaybeMessage<::objectstore::DeleteRowResponse>(Arena*);
template<> ::objectstore::ErrorResponse* Arena::CreateMaybeMessage<::objectstore::ErrorResponse>(Arena*);
template<> ::objectstore::Field* Arena::CreateMaybeMessage<::objectstore::Field>(Arena*);
template<> ::objectstore::FieldData* Arena::CreateMaybeMessage<::objectstore::FieldData>(Arena*);
template<> ::objectstore::FieldDef* Arena::CreateMaybeMessage<::objectstore::FieldDef>(Arena*);
template<> ::objectstore::GetTableInfoRequest* Arena::CreateMaybeMessage<::objectstore::GetTableInfoRequest>(Arena*);
template<> ::objectstore::GetTableInfoResponse* Arena::CreateMaybeMessage<::objectstore::GetTableInfoResponse>(Arena*);
template<> ::objectstore::InsertRowRequest* Arena::CreateMaybeMessage<::objectstore::InsertRowRequest>(Arena*);
template<> ::objectstore::InsertRowResponse* Arena::CreateMaybeMessage<::objectstore::InsertRowResponse>(Arena*);
template<> ::objectstore::QueryRowResponse* Arena::CreateMaybeMessage<::objectstore::QueryRowResponse>(Arena*);
template<> ::objectstore::QueryRowsRequest* Arena::CreateMaybeMessage<::objectstore::QueryRowsRequest>(Arena*);
template<> ::objectstore::RollbackTransactionRequest* Arena::CreateMaybeMessage<::objectstore::RollbackTransactionRequest>(Arena*);
template<> ::objectstore::RollbackTransactionResponse* Arena::CreateMaybeMessage<::objectstore::RollbackTransactionResponse>(Arena*);
template<> ::objectstore::StartTransactionRequest* Arena::CreateMaybeMessage<::objectstore::StartTransactionRequest>(Arena*);
template<> ::objectstore::StartTransactionResponse* Arena::CreateMaybeMessage<::objectstore::StartTransactionResponse>(Arena*);
template<> ::objectstore::TransactionRequest* Arena::CreateMaybeMessage<::objectstore::TransactionRequest>(Arena*);
template<> ::objectstore::TransactionResponse* Arena::CreateMaybeMessage<::objectstore::TransactionResponse>(Arena*);
template<> ::objectstore::UpdateRowRequest* Arena::CreateMaybeMessage<::objectstore::UpdateRowRequest>(Arena*);
template<> ::objectstore::UpdateRowResponse* Arena::CreateMaybeMessage<::objectstore::UpdateRowResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace objectstore {

enum FieldType : int {
  Null = 0,
  Int = 1,
  Float = 2,
  Bool = 3,
  String = 4,
  FieldType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FieldType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FieldType_IsValid(int value);
constexpr FieldType FieldType_MIN = Null;
constexpr FieldType FieldType_MAX = String;
constexpr int FieldType_ARRAYSIZE = FieldType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FieldType_descriptor();
template<typename T>
inline const std::string& FieldType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FieldType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FieldType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FieldType_descriptor(), enum_t_value);
}
inline bool FieldType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FieldType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FieldType>(
    FieldType_descriptor(), name, value);
}
// ===================================================================

class CreateTableRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.CreateTableRequest) */ {
 public:
  inline CreateTableRequest() : CreateTableRequest(nullptr) {}
  ~CreateTableRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateTableRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableRequest(const CreateTableRequest& from);
  CreateTableRequest(CreateTableRequest&& from) noexcept
    : CreateTableRequest() {
    *this = ::std::move(from);
  }

  inline CreateTableRequest& operator=(const CreateTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableRequest& operator=(CreateTableRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTableRequest*>(
               &_CreateTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateTableRequest& a, CreateTableRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateTableRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateTableRequest& from) {
    CreateTableRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTableRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.CreateTableRequest";
  }
  protected:
  explicit CreateTableRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 2,
    kTableNameFieldNumber = 1,
  };
  // repeated .objectstore.Field fields = 2;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::objectstore::Field* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_fields();
  private:
  const ::objectstore::Field& _internal_fields(int index) const;
  ::objectstore::Field* _internal_add_fields();
  public:
  const ::objectstore::Field& fields(int index) const;
  ::objectstore::Field* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      fields() const;

  // string tableName = 1;
  void clear_tablename();
  const std::string& tablename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablename();
  PROTOBUF_NODISCARD std::string* release_tablename();
  void set_allocated_tablename(std::string* tablename);
  private:
  const std::string& _internal_tablename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablename(const std::string& value);
  std::string* _internal_mutable_tablename();
  public:

  // @@protoc_insertion_point(class_scope:objectstore.CreateTableRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > fields_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class GetTableInfoRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.GetTableInfoRequest) */ {
 public:
  inline GetTableInfoRequest() : GetTableInfoRequest(nullptr) {}
  ~GetTableInfoRequest() override;
  explicit PROTOBUF_CONSTEXPR GetTableInfoRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTableInfoRequest(const GetTableInfoRequest& from);
  GetTableInfoRequest(GetTableInfoRequest&& from) noexcept
    : GetTableInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetTableInfoRequest& operator=(const GetTableInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTableInfoRequest& operator=(GetTableInfoRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTableInfoRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTableInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetTableInfoRequest*>(
               &_GetTableInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(GetTableInfoRequest& a, GetTableInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTableInfoRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTableInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTableInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTableInfoRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTableInfoRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTableInfoRequest& from) {
    GetTableInfoRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTableInfoRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.GetTableInfoRequest";
  }
  protected:
  explicit GetTableInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
  };
  // string tableName = 1;
  void clear_tablename();
  const std::string& tablename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablename();
  PROTOBUF_NODISCARD std::string* release_tablename();
  void set_allocated_tablename(std::string* tablename);
  private:
  const std::string& _internal_tablename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablename(const std::string& value);
  std::string* _internal_mutable_tablename();
  public:

  // @@protoc_insertion_point(class_scope:objectstore.GetTableInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablename_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class FieldDef final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.FieldDef) */ {
 public:
  inline FieldDef() : FieldDef(nullptr) {}
  ~FieldDef() override;
  explicit PROTOBUF_CONSTEXPR FieldDef(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldDef(const FieldDef& from);
  FieldDef(FieldDef&& from) noexcept
    : FieldDef() {
    *this = ::std::move(from);
  }

  inline FieldDef& operator=(const FieldDef& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldDef& operator=(FieldDef&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldDef& default_instance() {
    return *internal_default_instance();
  }
  static inline const FieldDef* internal_default_instance() {
    return reinterpret_cast<const FieldDef*>(
               &_FieldDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FieldDef& a, FieldDef& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldDef* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldDef* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldDef* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldDef>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldDef& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldDef& from) {
    FieldDef::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldDef* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.FieldDef";
  }
  protected:
  explicit FieldDef(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTypeFieldNumber = 2,
    kIsKeyFieldNumber = 3,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .objectstore.FieldType type = 2;
  void clear_type();
  ::objectstore::FieldType type() const;
  void set_type(::objectstore::FieldType value);
  private:
  ::objectstore::FieldType _internal_type() const;
  void _internal_set_type(::objectstore::FieldType value);
  public:

  // bool isKey = 3;
  void clear_iskey();
  bool iskey() const;
  void set_iskey(bool value);
  private:
  bool _internal_iskey() const;
  void _internal_set_iskey(bool value);
  public:

  // @@protoc_insertion_point(class_scope:objectstore.FieldDef)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int type_;
    bool iskey_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class CreateTableResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.CreateTableResponse) */ {
 public:
  inline CreateTableResponse() : CreateTableResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CreateTableResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateTableResponse(const CreateTableResponse& from);
  CreateTableResponse(CreateTableResponse&& from) noexcept
    : CreateTableResponse() {
    *this = ::std::move(from);
  }

  inline CreateTableResponse& operator=(const CreateTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateTableResponse& operator=(CreateTableResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateTableResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateTableResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTableResponse*>(
               &_CreateTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CreateTableResponse& a, CreateTableResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateTableResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateTableResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateTableResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateTableResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CreateTableResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CreateTableResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.CreateTableResponse";
  }
  protected:
  explicit CreateTableResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.CreateTableResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class GetTableInfoResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.GetTableInfoResponse) */ {
 public:
  inline GetTableInfoResponse() : GetTableInfoResponse(nullptr) {}
  ~GetTableInfoResponse() override;
  explicit PROTOBUF_CONSTEXPR GetTableInfoResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTableInfoResponse(const GetTableInfoResponse& from);
  GetTableInfoResponse(GetTableInfoResponse&& from) noexcept
    : GetTableInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetTableInfoResponse& operator=(const GetTableInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTableInfoResponse& operator=(GetTableInfoResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTableInfoResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTableInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetTableInfoResponse*>(
               &_GetTableInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetTableInfoResponse& a, GetTableInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTableInfoResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTableInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetTableInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetTableInfoResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTableInfoResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetTableInfoResponse& from) {
    GetTableInfoResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTableInfoResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.GetTableInfoResponse";
  }
  protected:
  explicit GetTableInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldsFieldNumber = 1,
  };
  // repeated .objectstore.FieldDef fields = 1;
  int fields_size() const;
  private:
  int _internal_fields_size() const;
  public:
  void clear_fields();
  ::objectstore::FieldDef* mutable_fields(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::FieldDef >*
      mutable_fields();
  private:
  const ::objectstore::FieldDef& _internal_fields(int index) const;
  ::objectstore::FieldDef* _internal_add_fields();
  public:
  const ::objectstore::FieldDef& fields(int index) const;
  ::objectstore::FieldDef* add_fields();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::FieldDef >&
      fields() const;

  // @@protoc_insertion_point(class_scope:objectstore.GetTableInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::FieldDef > fields_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class TransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.TransactionRequest) */ {
 public:
  inline TransactionRequest() : TransactionRequest(nullptr) {}
  ~TransactionRequest() override;
  explicit PROTOBUF_CONSTEXPR TransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionRequest(const TransactionRequest& from);
  TransactionRequest(TransactionRequest&& from) noexcept
    : TransactionRequest() {
    *this = ::std::move(from);
  }

  inline TransactionRequest& operator=(const TransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionRequest& operator=(TransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kStartTransaction = 1,
    kInsertRow = 2,
    kDeleteRow = 3,
    kQueryRows = 4,
    kUpdateRow = 5,
    kCommitTransaction = 6,
    kRollbackTransaction = 7,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const TransactionRequest* internal_default_instance() {
    return reinterpret_cast<const TransactionRequest*>(
               &_TransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TransactionRequest& a, TransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionRequest& from) {
    TransactionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.TransactionRequest";
  }
  protected:
  explicit TransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTransactionFieldNumber = 1,
    kInsertRowFieldNumber = 2,
    kDeleteRowFieldNumber = 3,
    kQueryRowsFieldNumber = 4,
    kUpdateRowFieldNumber = 5,
    kCommitTransactionFieldNumber = 6,
    kRollbackTransactionFieldNumber = 7,
  };
  // .objectstore.StartTransactionRequest startTransaction = 1;
  bool has_starttransaction() const;
  private:
  bool _internal_has_starttransaction() const;
  public:
  void clear_starttransaction();
  const ::objectstore::StartTransactionRequest& starttransaction() const;
  PROTOBUF_NODISCARD ::objectstore::StartTransactionRequest* release_starttransaction();
  ::objectstore::StartTransactionRequest* mutable_starttransaction();
  void set_allocated_starttransaction(::objectstore::StartTransactionRequest* starttransaction);
  private:
  const ::objectstore::StartTransactionRequest& _internal_starttransaction() const;
  ::objectstore::StartTransactionRequest* _internal_mutable_starttransaction();
  public:
  void unsafe_arena_set_allocated_starttransaction(
      ::objectstore::StartTransactionRequest* starttransaction);
  ::objectstore::StartTransactionRequest* unsafe_arena_release_starttransaction();

  // .objectstore.InsertRowRequest insertRow = 2;
  bool has_insertrow() const;
  private:
  bool _internal_has_insertrow() const;
  public:
  void clear_insertrow();
  const ::objectstore::InsertRowRequest& insertrow() const;
  PROTOBUF_NODISCARD ::objectstore::InsertRowRequest* release_insertrow();
  ::objectstore::InsertRowRequest* mutable_insertrow();
  void set_allocated_insertrow(::objectstore::InsertRowRequest* insertrow);
  private:
  const ::objectstore::InsertRowRequest& _internal_insertrow() const;
  ::objectstore::InsertRowRequest* _internal_mutable_insertrow();
  public:
  void unsafe_arena_set_allocated_insertrow(
      ::objectstore::InsertRowRequest* insertrow);
  ::objectstore::InsertRowRequest* unsafe_arena_release_insertrow();

  // .objectstore.DeleteRowRequest deleteRow = 3;
  bool has_deleterow() const;
  private:
  bool _internal_has_deleterow() const;
  public:
  void clear_deleterow();
  const ::objectstore::DeleteRowRequest& deleterow() const;
  PROTOBUF_NODISCARD ::objectstore::DeleteRowRequest* release_deleterow();
  ::objectstore::DeleteRowRequest* mutable_deleterow();
  void set_allocated_deleterow(::objectstore::DeleteRowRequest* deleterow);
  private:
  const ::objectstore::DeleteRowRequest& _internal_deleterow() const;
  ::objectstore::DeleteRowRequest* _internal_mutable_deleterow();
  public:
  void unsafe_arena_set_allocated_deleterow(
      ::objectstore::DeleteRowRequest* deleterow);
  ::objectstore::DeleteRowRequest* unsafe_arena_release_deleterow();

  // .objectstore.QueryRowsRequest queryRows = 4;
  bool has_queryrows() const;
  private:
  bool _internal_has_queryrows() const;
  public:
  void clear_queryrows();
  const ::objectstore::QueryRowsRequest& queryrows() const;
  PROTOBUF_NODISCARD ::objectstore::QueryRowsRequest* release_queryrows();
  ::objectstore::QueryRowsRequest* mutable_queryrows();
  void set_allocated_queryrows(::objectstore::QueryRowsRequest* queryrows);
  private:
  const ::objectstore::QueryRowsRequest& _internal_queryrows() const;
  ::objectstore::QueryRowsRequest* _internal_mutable_queryrows();
  public:
  void unsafe_arena_set_allocated_queryrows(
      ::objectstore::QueryRowsRequest* queryrows);
  ::objectstore::QueryRowsRequest* unsafe_arena_release_queryrows();

  // .objectstore.UpdateRowRequest updateRow = 5;
  bool has_updaterow() const;
  private:
  bool _internal_has_updaterow() const;
  public:
  void clear_updaterow();
  const ::objectstore::UpdateRowRequest& updaterow() const;
  PROTOBUF_NODISCARD ::objectstore::UpdateRowRequest* release_updaterow();
  ::objectstore::UpdateRowRequest* mutable_updaterow();
  void set_allocated_updaterow(::objectstore::UpdateRowRequest* updaterow);
  private:
  const ::objectstore::UpdateRowRequest& _internal_updaterow() const;
  ::objectstore::UpdateRowRequest* _internal_mutable_updaterow();
  public:
  void unsafe_arena_set_allocated_updaterow(
      ::objectstore::UpdateRowRequest* updaterow);
  ::objectstore::UpdateRowRequest* unsafe_arena_release_updaterow();

  // .objectstore.CommitTransactionRequest commitTransaction = 6;
  bool has_committransaction() const;
  private:
  bool _internal_has_committransaction() const;
  public:
  void clear_committransaction();
  const ::objectstore::CommitTransactionRequest& committransaction() const;
  PROTOBUF_NODISCARD ::objectstore::CommitTransactionRequest* release_committransaction();
  ::objectstore::CommitTransactionRequest* mutable_committransaction();
  void set_allocated_committransaction(::objectstore::CommitTransactionRequest* committransaction);
  private:
  const ::objectstore::CommitTransactionRequest& _internal_committransaction() const;
  ::objectstore::CommitTransactionRequest* _internal_mutable_committransaction();
  public:
  void unsafe_arena_set_allocated_committransaction(
      ::objectstore::CommitTransactionRequest* committransaction);
  ::objectstore::CommitTransactionRequest* unsafe_arena_release_committransaction();

  // .objectstore.RollbackTransactionRequest rollbackTransaction = 7;
  bool has_rollbacktransaction() const;
  private:
  bool _internal_has_rollbacktransaction() const;
  public:
  void clear_rollbacktransaction();
  const ::objectstore::RollbackTransactionRequest& rollbacktransaction() const;
  PROTOBUF_NODISCARD ::objectstore::RollbackTransactionRequest* release_rollbacktransaction();
  ::objectstore::RollbackTransactionRequest* mutable_rollbacktransaction();
  void set_allocated_rollbacktransaction(::objectstore::RollbackTransactionRequest* rollbacktransaction);
  private:
  const ::objectstore::RollbackTransactionRequest& _internal_rollbacktransaction() const;
  ::objectstore::RollbackTransactionRequest* _internal_mutable_rollbacktransaction();
  public:
  void unsafe_arena_set_allocated_rollbacktransaction(
      ::objectstore::RollbackTransactionRequest* rollbacktransaction);
  ::objectstore::RollbackTransactionRequest* unsafe_arena_release_rollbacktransaction();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:objectstore.TransactionRequest)
 private:
  class _Internal;
  void set_has_starttransaction();
  void set_has_insertrow();
  void set_has_deleterow();
  void set_has_queryrows();
  void set_has_updaterow();
  void set_has_committransaction();
  void set_has_rollbacktransaction();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::objectstore::StartTransactionRequest* starttransaction_;
      ::objectstore::InsertRowRequest* insertrow_;
      ::objectstore::DeleteRowRequest* deleterow_;
      ::objectstore::QueryRowsRequest* queryrows_;
      ::objectstore::UpdateRowRequest* updaterow_;
      ::objectstore::CommitTransactionRequest* committransaction_;
      ::objectstore::RollbackTransactionRequest* rollbacktransaction_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class TransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.TransactionResponse) */ {
 public:
  inline TransactionResponse() : TransactionResponse(nullptr) {}
  ~TransactionResponse() override;
  explicit PROTOBUF_CONSTEXPR TransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionResponse(const TransactionResponse& from);
  TransactionResponse(TransactionResponse&& from) noexcept
    : TransactionResponse() {
    *this = ::std::move(from);
  }

  inline TransactionResponse& operator=(const TransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionResponse& operator=(TransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kStartTransaction = 1,
    kInsertRow = 2,
    kDeleteRow = 3,
    kQueryRows = 4,
    kUpdateRow = 5,
    kCommitTransaction = 6,
    kRollbackTransaction = 7,
    kError = 8,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const TransactionResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionResponse*>(
               &_TransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TransactionResponse& a, TransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionResponse& from) {
    TransactionResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.TransactionResponse";
  }
  protected:
  explicit TransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTransactionFieldNumber = 1,
    kInsertRowFieldNumber = 2,
    kDeleteRowFieldNumber = 3,
    kQueryRowsFieldNumber = 4,
    kUpdateRowFieldNumber = 5,
    kCommitTransactionFieldNumber = 6,
    kRollbackTransactionFieldNumber = 7,
    kErrorFieldNumber = 8,
  };
  // .objectstore.StartTransactionResponse startTransaction = 1;
  bool has_starttransaction() const;
  private:
  bool _internal_has_starttransaction() const;
  public:
  void clear_starttransaction();
  const ::objectstore::StartTransactionResponse& starttransaction() const;
  PROTOBUF_NODISCARD ::objectstore::StartTransactionResponse* release_starttransaction();
  ::objectstore::StartTransactionResponse* mutable_starttransaction();
  void set_allocated_starttransaction(::objectstore::StartTransactionResponse* starttransaction);
  private:
  const ::objectstore::StartTransactionResponse& _internal_starttransaction() const;
  ::objectstore::StartTransactionResponse* _internal_mutable_starttransaction();
  public:
  void unsafe_arena_set_allocated_starttransaction(
      ::objectstore::StartTransactionResponse* starttransaction);
  ::objectstore::StartTransactionResponse* unsafe_arena_release_starttransaction();

  // .objectstore.InsertRowResponse insertRow = 2;
  bool has_insertrow() const;
  private:
  bool _internal_has_insertrow() const;
  public:
  void clear_insertrow();
  const ::objectstore::InsertRowResponse& insertrow() const;
  PROTOBUF_NODISCARD ::objectstore::InsertRowResponse* release_insertrow();
  ::objectstore::InsertRowResponse* mutable_insertrow();
  void set_allocated_insertrow(::objectstore::InsertRowResponse* insertrow);
  private:
  const ::objectstore::InsertRowResponse& _internal_insertrow() const;
  ::objectstore::InsertRowResponse* _internal_mutable_insertrow();
  public:
  void unsafe_arena_set_allocated_insertrow(
      ::objectstore::InsertRowResponse* insertrow);
  ::objectstore::InsertRowResponse* unsafe_arena_release_insertrow();

  // .objectstore.DeleteRowResponse deleteRow = 3;
  bool has_deleterow() const;
  private:
  bool _internal_has_deleterow() const;
  public:
  void clear_deleterow();
  const ::objectstore::DeleteRowResponse& deleterow() const;
  PROTOBUF_NODISCARD ::objectstore::DeleteRowResponse* release_deleterow();
  ::objectstore::DeleteRowResponse* mutable_deleterow();
  void set_allocated_deleterow(::objectstore::DeleteRowResponse* deleterow);
  private:
  const ::objectstore::DeleteRowResponse& _internal_deleterow() const;
  ::objectstore::DeleteRowResponse* _internal_mutable_deleterow();
  public:
  void unsafe_arena_set_allocated_deleterow(
      ::objectstore::DeleteRowResponse* deleterow);
  ::objectstore::DeleteRowResponse* unsafe_arena_release_deleterow();

  // .objectstore.QueryRowResponse queryRows = 4;
  bool has_queryrows() const;
  private:
  bool _internal_has_queryrows() const;
  public:
  void clear_queryrows();
  const ::objectstore::QueryRowResponse& queryrows() const;
  PROTOBUF_NODISCARD ::objectstore::QueryRowResponse* release_queryrows();
  ::objectstore::QueryRowResponse* mutable_queryrows();
  void set_allocated_queryrows(::objectstore::QueryRowResponse* queryrows);
  private:
  const ::objectstore::QueryRowResponse& _internal_queryrows() const;
  ::objectstore::QueryRowResponse* _internal_mutable_queryrows();
  public:
  void unsafe_arena_set_allocated_queryrows(
      ::objectstore::QueryRowResponse* queryrows);
  ::objectstore::QueryRowResponse* unsafe_arena_release_queryrows();

  // .objectstore.UpdateRowResponse updateRow = 5;
  bool has_updaterow() const;
  private:
  bool _internal_has_updaterow() const;
  public:
  void clear_updaterow();
  const ::objectstore::UpdateRowResponse& updaterow() const;
  PROTOBUF_NODISCARD ::objectstore::UpdateRowResponse* release_updaterow();
  ::objectstore::UpdateRowResponse* mutable_updaterow();
  void set_allocated_updaterow(::objectstore::UpdateRowResponse* updaterow);
  private:
  const ::objectstore::UpdateRowResponse& _internal_updaterow() const;
  ::objectstore::UpdateRowResponse* _internal_mutable_updaterow();
  public:
  void unsafe_arena_set_allocated_updaterow(
      ::objectstore::UpdateRowResponse* updaterow);
  ::objectstore::UpdateRowResponse* unsafe_arena_release_updaterow();

  // .objectstore.CommitTransactionResponse commitTransaction = 6;
  bool has_committransaction() const;
  private:
  bool _internal_has_committransaction() const;
  public:
  void clear_committransaction();
  const ::objectstore::CommitTransactionResponse& committransaction() const;
  PROTOBUF_NODISCARD ::objectstore::CommitTransactionResponse* release_committransaction();
  ::objectstore::CommitTransactionResponse* mutable_committransaction();
  void set_allocated_committransaction(::objectstore::CommitTransactionResponse* committransaction);
  private:
  const ::objectstore::CommitTransactionResponse& _internal_committransaction() const;
  ::objectstore::CommitTransactionResponse* _internal_mutable_committransaction();
  public:
  void unsafe_arena_set_allocated_committransaction(
      ::objectstore::CommitTransactionResponse* committransaction);
  ::objectstore::CommitTransactionResponse* unsafe_arena_release_committransaction();

  // .objectstore.RollbackTransactionResponse rollbackTransaction = 7;
  bool has_rollbacktransaction() const;
  private:
  bool _internal_has_rollbacktransaction() const;
  public:
  void clear_rollbacktransaction();
  const ::objectstore::RollbackTransactionResponse& rollbacktransaction() const;
  PROTOBUF_NODISCARD ::objectstore::RollbackTransactionResponse* release_rollbacktransaction();
  ::objectstore::RollbackTransactionResponse* mutable_rollbacktransaction();
  void set_allocated_rollbacktransaction(::objectstore::RollbackTransactionResponse* rollbacktransaction);
  private:
  const ::objectstore::RollbackTransactionResponse& _internal_rollbacktransaction() const;
  ::objectstore::RollbackTransactionResponse* _internal_mutable_rollbacktransaction();
  public:
  void unsafe_arena_set_allocated_rollbacktransaction(
      ::objectstore::RollbackTransactionResponse* rollbacktransaction);
  ::objectstore::RollbackTransactionResponse* unsafe_arena_release_rollbacktransaction();

  // .objectstore.ErrorResponse error = 8;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::objectstore::ErrorResponse& error() const;
  PROTOBUF_NODISCARD ::objectstore::ErrorResponse* release_error();
  ::objectstore::ErrorResponse* mutable_error();
  void set_allocated_error(::objectstore::ErrorResponse* error);
  private:
  const ::objectstore::ErrorResponse& _internal_error() const;
  ::objectstore::ErrorResponse* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::objectstore::ErrorResponse* error);
  ::objectstore::ErrorResponse* unsafe_arena_release_error();

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:objectstore.TransactionResponse)
 private:
  class _Internal;
  void set_has_starttransaction();
  void set_has_insertrow();
  void set_has_deleterow();
  void set_has_queryrows();
  void set_has_updaterow();
  void set_has_committransaction();
  void set_has_rollbacktransaction();
  void set_has_error();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::objectstore::StartTransactionResponse* starttransaction_;
      ::objectstore::InsertRowResponse* insertrow_;
      ::objectstore::DeleteRowResponse* deleterow_;
      ::objectstore::QueryRowResponse* queryrows_;
      ::objectstore::UpdateRowResponse* updaterow_;
      ::objectstore::CommitTransactionResponse* committransaction_;
      ::objectstore::RollbackTransactionResponse* rollbacktransaction_;
      ::objectstore::ErrorResponse* error_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class FieldData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.FieldData) */ {
 public:
  inline FieldData() : FieldData(nullptr) {}
  ~FieldData() override;
  explicit PROTOBUF_CONSTEXPR FieldData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FieldData(const FieldData& from);
  FieldData(FieldData&& from) noexcept
    : FieldData() {
    *this = ::std::move(from);
  }

  inline FieldData& operator=(const FieldData& from) {
    CopyFrom(from);
    return *this;
  }
  inline FieldData& operator=(FieldData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FieldData& default_instance() {
    return *internal_default_instance();
  }
  enum PayloadCase {
    kIntMember = 1,
    kFloatMember = 2,
    kBoolMember = 3,
    kStringMember = 4,
    PAYLOAD_NOT_SET = 0,
  };

  static inline const FieldData* internal_default_instance() {
    return reinterpret_cast<const FieldData*>(
               &_FieldData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FieldData& a, FieldData& b) {
    a.Swap(&b);
  }
  inline void Swap(FieldData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FieldData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FieldData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FieldData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FieldData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FieldData& from) {
    FieldData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.FieldData";
  }
  protected:
  explicit FieldData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntMemberFieldNumber = 1,
    kFloatMemberFieldNumber = 2,
    kBoolMemberFieldNumber = 3,
    kStringMemberFieldNumber = 4,
  };
  // int64 intMember = 1;
  bool has_intmember() const;
  private:
  bool _internal_has_intmember() const;
  public:
  void clear_intmember();
  int64_t intmember() const;
  void set_intmember(int64_t value);
  private:
  int64_t _internal_intmember() const;
  void _internal_set_intmember(int64_t value);
  public:

  // double floatMember = 2;
  bool has_floatmember() const;
  private:
  bool _internal_has_floatmember() const;
  public:
  void clear_floatmember();
  double floatmember() const;
  void set_floatmember(double value);
  private:
  double _internal_floatmember() const;
  void _internal_set_floatmember(double value);
  public:

  // bool boolMember = 3;
  bool has_boolmember() const;
  private:
  bool _internal_has_boolmember() const;
  public:
  void clear_boolmember();
  bool boolmember() const;
  void set_boolmember(bool value);
  private:
  bool _internal_boolmember() const;
  void _internal_set_boolmember(bool value);
  public:

  // string stringMember = 4;
  bool has_stringmember() const;
  private:
  bool _internal_has_stringmember() const;
  public:
  void clear_stringmember();
  const std::string& stringmember() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stringmember(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stringmember();
  PROTOBUF_NODISCARD std::string* release_stringmember();
  void set_allocated_stringmember(std::string* stringmember);
  private:
  const std::string& _internal_stringmember() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stringmember(const std::string& value);
  std::string* _internal_mutable_stringmember();
  public:

  void clear_payload();
  PayloadCase payload_case() const;
  // @@protoc_insertion_point(class_scope:objectstore.FieldData)
 private:
  class _Internal;
  void set_has_intmember();
  void set_has_floatmember();
  void set_has_boolmember();
  void set_has_stringmember();

  inline bool has_payload() const;
  inline void clear_has_payload();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union PayloadUnion {
      constexpr PayloadUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      int64_t intmember_;
      double floatmember_;
      bool boolmember_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stringmember_;
    } payload_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class Field final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.Field) */ {
 public:
  inline Field() : Field(nullptr) {}
  ~Field() override;
  explicit PROTOBUF_CONSTEXPR Field(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Field(const Field& from);
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  inline Field& operator=(Field&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Field& default_instance() {
    return *internal_default_instance();
  }
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }
  inline void Swap(Field* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Field* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Field* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Field& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Field& from) {
    Field::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.Field";
  }
  protected:
  explicit Field(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kDataFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .objectstore.FieldData data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::objectstore::FieldData& data() const;
  PROTOBUF_NODISCARD ::objectstore::FieldData* release_data();
  ::objectstore::FieldData* mutable_data();
  void set_allocated_data(::objectstore::FieldData* data);
  private:
  const ::objectstore::FieldData& _internal_data() const;
  ::objectstore::FieldData* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::objectstore::FieldData* data);
  ::objectstore::FieldData* unsafe_arena_release_data();

  // .objectstore.FieldType type = 2;
  void clear_type();
  ::objectstore::FieldType type() const;
  void set_type(::objectstore::FieldType value);
  private:
  ::objectstore::FieldType _internal_type() const;
  void _internal_set_type(::objectstore::FieldType value);
  public:

  // @@protoc_insertion_point(class_scope:objectstore.Field)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::objectstore::FieldData* data_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class StartTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.StartTransactionRequest) */ {
 public:
  inline StartTransactionRequest() : StartTransactionRequest(nullptr) {}
  ~StartTransactionRequest() override;
  explicit PROTOBUF_CONSTEXPR StartTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartTransactionRequest(const StartTransactionRequest& from);
  StartTransactionRequest(StartTransactionRequest&& from) noexcept
    : StartTransactionRequest() {
    *this = ::std::move(from);
  }

  inline StartTransactionRequest& operator=(const StartTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartTransactionRequest& operator=(StartTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const StartTransactionRequest*>(
               &_StartTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StartTransactionRequest& a, StartTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StartTransactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StartTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StartTransactionRequest& from) {
    StartTransactionRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StartTransactionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.StartTransactionRequest";
  }
  protected:
  explicit StartTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kWritableFieldNumber = 2,
  };
  // string tableName = 1;
  void clear_tablename();
  const std::string& tablename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tablename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tablename();
  PROTOBUF_NODISCARD std::string* release_tablename();
  void set_allocated_tablename(std::string* tablename);
  private:
  const std::string& _internal_tablename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tablename(const std::string& value);
  std::string* _internal_mutable_tablename();
  public:

  // bool writable = 2;
  void clear_writable();
  bool writable() const;
  void set_writable(bool value);
  private:
  bool _internal_writable() const;
  void _internal_set_writable(bool value);
  public:

  // @@protoc_insertion_point(class_scope:objectstore.StartTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tablename_;
    bool writable_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class StartTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.StartTransactionResponse) */ {
 public:
  inline StartTransactionResponse() : StartTransactionResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR StartTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StartTransactionResponse(const StartTransactionResponse& from);
  StartTransactionResponse(StartTransactionResponse&& from) noexcept
    : StartTransactionResponse() {
    *this = ::std::move(from);
  }

  inline StartTransactionResponse& operator=(const StartTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline StartTransactionResponse& operator=(StartTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StartTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const StartTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const StartTransactionResponse*>(
               &_StartTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StartTransactionResponse& a, StartTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(StartTransactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StartTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StartTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StartTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const StartTransactionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const StartTransactionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.StartTransactionResponse";
  }
  protected:
  explicit StartTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.StartTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class CommitTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.CommitTransactionRequest) */ {
 public:
  inline CommitTransactionRequest() : CommitTransactionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CommitTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitTransactionRequest(const CommitTransactionRequest& from);
  CommitTransactionRequest(CommitTransactionRequest&& from) noexcept
    : CommitTransactionRequest() {
    *this = ::std::move(from);
  }

  inline CommitTransactionRequest& operator=(const CommitTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitTransactionRequest& operator=(CommitTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const CommitTransactionRequest*>(
               &_CommitTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommitTransactionRequest& a, CommitTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitTransactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommitTransactionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommitTransactionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.CommitTransactionRequest";
  }
  protected:
  explicit CommitTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.CommitTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class CommitTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.CommitTransactionResponse) */ {
 public:
  inline CommitTransactionResponse() : CommitTransactionResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CommitTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitTransactionResponse(const CommitTransactionResponse& from);
  CommitTransactionResponse(CommitTransactionResponse&& from) noexcept
    : CommitTransactionResponse() {
    *this = ::std::move(from);
  }

  inline CommitTransactionResponse& operator=(const CommitTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitTransactionResponse& operator=(CommitTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CommitTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const CommitTransactionResponse*>(
               &_CommitTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CommitTransactionResponse& a, CommitTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CommitTransactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CommitTransactionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CommitTransactionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.CommitTransactionResponse";
  }
  protected:
  explicit CommitTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.CommitTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class RollbackTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.RollbackTransactionRequest) */ {
 public:
  inline RollbackTransactionRequest() : RollbackTransactionRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RollbackTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RollbackTransactionRequest(const RollbackTransactionRequest& from);
  RollbackTransactionRequest(RollbackTransactionRequest&& from) noexcept
    : RollbackTransactionRequest() {
    *this = ::std::move(from);
  }

  inline RollbackTransactionRequest& operator=(const RollbackTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollbackTransactionRequest& operator=(RollbackTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollbackTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RollbackTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const RollbackTransactionRequest*>(
               &_RollbackTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RollbackTransactionRequest& a, RollbackTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RollbackTransactionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollbackTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollbackTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RollbackTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RollbackTransactionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RollbackTransactionRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.RollbackTransactionRequest";
  }
  protected:
  explicit RollbackTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.RollbackTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class RollbackTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.RollbackTransactionResponse) */ {
 public:
  inline RollbackTransactionResponse() : RollbackTransactionResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RollbackTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RollbackTransactionResponse(const RollbackTransactionResponse& from);
  RollbackTransactionResponse(RollbackTransactionResponse&& from) noexcept
    : RollbackTransactionResponse() {
    *this = ::std::move(from);
  }

  inline RollbackTransactionResponse& operator=(const RollbackTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollbackTransactionResponse& operator=(RollbackTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollbackTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RollbackTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const RollbackTransactionResponse*>(
               &_RollbackTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RollbackTransactionResponse& a, RollbackTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RollbackTransactionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollbackTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollbackTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RollbackTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RollbackTransactionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RollbackTransactionResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.RollbackTransactionResponse";
  }
  protected:
  explicit RollbackTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.RollbackTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class InsertRowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.InsertRowRequest) */ {
 public:
  inline InsertRowRequest() : InsertRowRequest(nullptr) {}
  ~InsertRowRequest() override;
  explicit PROTOBUF_CONSTEXPR InsertRowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRowRequest(const InsertRowRequest& from);
  InsertRowRequest(InsertRowRequest&& from) noexcept
    : InsertRowRequest() {
    *this = ::std::move(from);
  }

  inline InsertRowRequest& operator=(const InsertRowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRowRequest& operator=(InsertRowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRowRequest* internal_default_instance() {
    return reinterpret_cast<const InsertRowRequest*>(
               &_InsertRowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(InsertRowRequest& a, InsertRowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const InsertRowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const InsertRowRequest& from) {
    InsertRowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertRowRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.InsertRowRequest";
  }
  protected:
  explicit InsertRowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .objectstore.Field value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::objectstore::Field* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_value();
  private:
  const ::objectstore::Field& _internal_value(int index) const;
  ::objectstore::Field* _internal_add_value();
  public:
  const ::objectstore::Field& value(int index) const;
  ::objectstore::Field* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      value() const;

  // @@protoc_insertion_point(class_scope:objectstore.InsertRowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class InsertRowResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.InsertRowResponse) */ {
 public:
  inline InsertRowResponse() : InsertRowResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR InsertRowResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InsertRowResponse(const InsertRowResponse& from);
  InsertRowResponse(InsertRowResponse&& from) noexcept
    : InsertRowResponse() {
    *this = ::std::move(from);
  }

  inline InsertRowResponse& operator=(const InsertRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline InsertRowResponse& operator=(InsertRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const InsertRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const InsertRowResponse* internal_default_instance() {
    return reinterpret_cast<const InsertRowResponse*>(
               &_InsertRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(InsertRowResponse& a, InsertRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(InsertRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InsertRowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InsertRowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InsertRowResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const InsertRowResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const InsertRowResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.InsertRowResponse";
  }
  protected:
  explicit InsertRowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.InsertRowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class DeleteRowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.DeleteRowRequest) */ {
 public:
  inline DeleteRowRequest() : DeleteRowRequest(nullptr) {}
  ~DeleteRowRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRowRequest(const DeleteRowRequest& from);
  DeleteRowRequest(DeleteRowRequest&& from) noexcept
    : DeleteRowRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRowRequest& operator=(const DeleteRowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRowRequest& operator=(DeleteRowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRowRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRowRequest*>(
               &_DeleteRowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteRowRequest& a, DeleteRowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRowRequest& from) {
    DeleteRowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRowRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.DeleteRowRequest";
  }
  protected:
  explicit DeleteRowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 1,
  };
  // repeated .objectstore.Field conditions = 1;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::objectstore::Field* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_conditions();
  private:
  const ::objectstore::Field& _internal_conditions(int index) const;
  ::objectstore::Field* _internal_add_conditions();
  public:
  const ::objectstore::Field& conditions(int index) const;
  ::objectstore::Field* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      conditions() const;

  // @@protoc_insertion_point(class_scope:objectstore.DeleteRowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > conditions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class DeleteRowResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.DeleteRowResponse) */ {
 public:
  inline DeleteRowResponse() : DeleteRowResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteRowResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRowResponse(const DeleteRowResponse& from);
  DeleteRowResponse(DeleteRowResponse&& from) noexcept
    : DeleteRowResponse() {
    *this = ::std::move(from);
  }

  inline DeleteRowResponse& operator=(const DeleteRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRowResponse& operator=(DeleteRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRowResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteRowResponse*>(
               &_DeleteRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteRowResponse& a, DeleteRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRowResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteRowResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteRowResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.DeleteRowResponse";
  }
  protected:
  explicit DeleteRowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.DeleteRowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class QueryRowsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.QueryRowsRequest) */ {
 public:
  inline QueryRowsRequest() : QueryRowsRequest(nullptr) {}
  ~QueryRowsRequest() override;
  explicit PROTOBUF_CONSTEXPR QueryRowsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRowsRequest(const QueryRowsRequest& from);
  QueryRowsRequest(QueryRowsRequest&& from) noexcept
    : QueryRowsRequest() {
    *this = ::std::move(from);
  }

  inline QueryRowsRequest& operator=(const QueryRowsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRowsRequest& operator=(QueryRowsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRowsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRowsRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRowsRequest*>(
               &_QueryRowsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(QueryRowsRequest& a, QueryRowsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRowsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRowsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRowsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRowsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRowsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryRowsRequest& from) {
    QueryRowsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRowsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.QueryRowsRequest";
  }
  protected:
  explicit QueryRowsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConditionsFieldNumber = 1,
  };
  // repeated .objectstore.Field conditions = 1;
  int conditions_size() const;
  private:
  int _internal_conditions_size() const;
  public:
  void clear_conditions();
  ::objectstore::Field* mutable_conditions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_conditions();
  private:
  const ::objectstore::Field& _internal_conditions(int index) const;
  ::objectstore::Field* _internal_add_conditions();
  public:
  const ::objectstore::Field& conditions(int index) const;
  ::objectstore::Field* add_conditions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      conditions() const;

  // @@protoc_insertion_point(class_scope:objectstore.QueryRowsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > conditions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class QueryRowResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.QueryRowResponse) */ {
 public:
  inline QueryRowResponse() : QueryRowResponse(nullptr) {}
  ~QueryRowResponse() override;
  explicit PROTOBUF_CONSTEXPR QueryRowResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRowResponse(const QueryRowResponse& from);
  QueryRowResponse(QueryRowResponse&& from) noexcept
    : QueryRowResponse() {
    *this = ::std::move(from);
  }

  inline QueryRowResponse& operator=(const QueryRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRowResponse& operator=(QueryRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRowResponse* internal_default_instance() {
    return reinterpret_cast<const QueryRowResponse*>(
               &_QueryRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(QueryRowResponse& a, QueryRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRowResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRowResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QueryRowResponse& from) {
    QueryRowResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRowResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.QueryRowResponse";
  }
  protected:
  explicit QueryRowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated .objectstore.Field key = 1;
  int key_size() const;
  private:
  int _internal_key_size() const;
  public:
  void clear_key();
  ::objectstore::Field* mutable_key(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_key();
  private:
  const ::objectstore::Field& _internal_key(int index) const;
  ::objectstore::Field* _internal_add_key();
  public:
  const ::objectstore::Field& key(int index) const;
  ::objectstore::Field* add_key();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      key() const;

  // repeated .objectstore.Field value = 2;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::objectstore::Field* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_value();
  private:
  const ::objectstore::Field& _internal_value(int index) const;
  ::objectstore::Field* _internal_add_value();
  public:
  const ::objectstore::Field& value(int index) const;
  ::objectstore::Field* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      value() const;

  // @@protoc_insertion_point(class_scope:objectstore.QueryRowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > key_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class UpdateRowRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.UpdateRowRequest) */ {
 public:
  inline UpdateRowRequest() : UpdateRowRequest(nullptr) {}
  ~UpdateRowRequest() override;
  explicit PROTOBUF_CONSTEXPR UpdateRowRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRowRequest(const UpdateRowRequest& from);
  UpdateRowRequest(UpdateRowRequest&& from) noexcept
    : UpdateRowRequest() {
    *this = ::std::move(from);
  }

  inline UpdateRowRequest& operator=(const UpdateRowRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRowRequest& operator=(UpdateRowRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRowRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRowRequest* internal_default_instance() {
    return reinterpret_cast<const UpdateRowRequest*>(
               &_UpdateRowRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UpdateRowRequest& a, UpdateRowRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRowRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRowRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRowRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRowRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UpdateRowRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UpdateRowRequest& from) {
    UpdateRowRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRowRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.UpdateRowRequest";
  }
  protected:
  explicit UpdateRowRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // repeated .objectstore.Field key = 1;
  int key_size() const;
  private:
  int _internal_key_size() const;
  public:
  void clear_key();
  ::objectstore::Field* mutable_key(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_key();
  private:
  const ::objectstore::Field& _internal_key(int index) const;
  ::objectstore::Field* _internal_add_key();
  public:
  const ::objectstore::Field& key(int index) const;
  ::objectstore::Field* add_key();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      key() const;

  // repeated .objectstore.Field value = 2;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::objectstore::Field* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
      mutable_value();
  private:
  const ::objectstore::Field& _internal_value(int index) const;
  ::objectstore::Field* _internal_add_value();
  public:
  const ::objectstore::Field& value(int index) const;
  ::objectstore::Field* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
      value() const;

  // @@protoc_insertion_point(class_scope:objectstore.UpdateRowRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > key_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field > value_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class UpdateRowResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:objectstore.UpdateRowResponse) */ {
 public:
  inline UpdateRowResponse() : UpdateRowResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR UpdateRowResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UpdateRowResponse(const UpdateRowResponse& from);
  UpdateRowResponse(UpdateRowResponse&& from) noexcept
    : UpdateRowResponse() {
    *this = ::std::move(from);
  }

  inline UpdateRowResponse& operator=(const UpdateRowResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline UpdateRowResponse& operator=(UpdateRowResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UpdateRowResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const UpdateRowResponse* internal_default_instance() {
    return reinterpret_cast<const UpdateRowResponse*>(
               &_UpdateRowResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(UpdateRowResponse& a, UpdateRowResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(UpdateRowResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UpdateRowResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UpdateRowResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UpdateRowResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const UpdateRowResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const UpdateRowResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.UpdateRowResponse";
  }
  protected:
  explicit UpdateRowResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:objectstore.UpdateRowResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_definition_2eproto;
};
// -------------------------------------------------------------------

class ErrorResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:objectstore.ErrorResponse) */ {
 public:
  inline ErrorResponse() : ErrorResponse(nullptr) {}
  ~ErrorResponse() override;
  explicit PROTOBUF_CONSTEXPR ErrorResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorResponse(const ErrorResponse& from);
  ErrorResponse(ErrorResponse&& from) noexcept
    : ErrorResponse() {
    *this = ::std::move(from);
  }

  inline ErrorResponse& operator=(const ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorResponse& operator=(ErrorResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ErrorResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorResponse* internal_default_instance() {
    return reinterpret_cast<const ErrorResponse*>(
               &_ErrorResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ErrorResponse& a, ErrorResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ErrorResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ErrorResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ErrorResponse& from) {
    ErrorResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ErrorResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "objectstore.ErrorResponse";
  }
  protected:
  explicit ErrorResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:objectstore.ErrorResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_definition_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateTableRequest

// string tableName = 1;
inline void CreateTableRequest::clear_tablename() {
  _impl_.tablename_.ClearToEmpty();
}
inline const std::string& CreateTableRequest::tablename() const {
  // @@protoc_insertion_point(field_get:objectstore.CreateTableRequest.tableName)
  return _internal_tablename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateTableRequest::set_tablename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tablename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:objectstore.CreateTableRequest.tableName)
}
inline std::string* CreateTableRequest::mutable_tablename() {
  std::string* _s = _internal_mutable_tablename();
  // @@protoc_insertion_point(field_mutable:objectstore.CreateTableRequest.tableName)
  return _s;
}
inline const std::string& CreateTableRequest::_internal_tablename() const {
  return _impl_.tablename_.Get();
}
inline void CreateTableRequest::_internal_set_tablename(const std::string& value) {
  
  _impl_.tablename_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateTableRequest::_internal_mutable_tablename() {
  
  return _impl_.tablename_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateTableRequest::release_tablename() {
  // @@protoc_insertion_point(field_release:objectstore.CreateTableRequest.tableName)
  return _impl_.tablename_.Release();
}
inline void CreateTableRequest::set_allocated_tablename(std::string* tablename) {
  if (tablename != nullptr) {
    
  } else {
    
  }
  _impl_.tablename_.SetAllocated(tablename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablename_.IsDefault()) {
    _impl_.tablename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:objectstore.CreateTableRequest.tableName)
}

// repeated .objectstore.Field fields = 2;
inline int CreateTableRequest::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int CreateTableRequest::fields_size() const {
  return _internal_fields_size();
}
inline void CreateTableRequest::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::objectstore::Field* CreateTableRequest::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.CreateTableRequest.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
CreateTableRequest::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.CreateTableRequest.fields)
  return &_impl_.fields_;
}
inline const ::objectstore::Field& CreateTableRequest::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::objectstore::Field& CreateTableRequest::fields(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.CreateTableRequest.fields)
  return _internal_fields(index);
}
inline ::objectstore::Field* CreateTableRequest::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::objectstore::Field* CreateTableRequest::add_fields() {
  ::objectstore::Field* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:objectstore.CreateTableRequest.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
CreateTableRequest::fields() const {
  // @@protoc_insertion_point(field_list:objectstore.CreateTableRequest.fields)
  return _impl_.fields_;
}

// -------------------------------------------------------------------

// GetTableInfoRequest

// string tableName = 1;
inline void GetTableInfoRequest::clear_tablename() {
  _impl_.tablename_.ClearToEmpty();
}
inline const std::string& GetTableInfoRequest::tablename() const {
  // @@protoc_insertion_point(field_get:objectstore.GetTableInfoRequest.tableName)
  return _internal_tablename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTableInfoRequest::set_tablename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tablename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:objectstore.GetTableInfoRequest.tableName)
}
inline std::string* GetTableInfoRequest::mutable_tablename() {
  std::string* _s = _internal_mutable_tablename();
  // @@protoc_insertion_point(field_mutable:objectstore.GetTableInfoRequest.tableName)
  return _s;
}
inline const std::string& GetTableInfoRequest::_internal_tablename() const {
  return _impl_.tablename_.Get();
}
inline void GetTableInfoRequest::_internal_set_tablename(const std::string& value) {
  
  _impl_.tablename_.Set(value, GetArenaForAllocation());
}
inline std::string* GetTableInfoRequest::_internal_mutable_tablename() {
  
  return _impl_.tablename_.Mutable(GetArenaForAllocation());
}
inline std::string* GetTableInfoRequest::release_tablename() {
  // @@protoc_insertion_point(field_release:objectstore.GetTableInfoRequest.tableName)
  return _impl_.tablename_.Release();
}
inline void GetTableInfoRequest::set_allocated_tablename(std::string* tablename) {
  if (tablename != nullptr) {
    
  } else {
    
  }
  _impl_.tablename_.SetAllocated(tablename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablename_.IsDefault()) {
    _impl_.tablename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:objectstore.GetTableInfoRequest.tableName)
}

// -------------------------------------------------------------------

// FieldDef

// string name = 1;
inline void FieldDef::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& FieldDef::name() const {
  // @@protoc_insertion_point(field_get:objectstore.FieldDef.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FieldDef::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:objectstore.FieldDef.name)
}
inline std::string* FieldDef::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:objectstore.FieldDef.name)
  return _s;
}
inline const std::string& FieldDef::_internal_name() const {
  return _impl_.name_.Get();
}
inline void FieldDef::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldDef::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* FieldDef::release_name() {
  // @@protoc_insertion_point(field_release:objectstore.FieldDef.name)
  return _impl_.name_.Release();
}
inline void FieldDef::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:objectstore.FieldDef.name)
}

// .objectstore.FieldType type = 2;
inline void FieldDef::clear_type() {
  _impl_.type_ = 0;
}
inline ::objectstore::FieldType FieldDef::_internal_type() const {
  return static_cast< ::objectstore::FieldType >(_impl_.type_);
}
inline ::objectstore::FieldType FieldDef::type() const {
  // @@protoc_insertion_point(field_get:objectstore.FieldDef.type)
  return _internal_type();
}
inline void FieldDef::_internal_set_type(::objectstore::FieldType value) {
  
  _impl_.type_ = value;
}
inline void FieldDef::set_type(::objectstore::FieldType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:objectstore.FieldDef.type)
}

// bool isKey = 3;
inline void FieldDef::clear_iskey() {
  _impl_.iskey_ = false;
}
inline bool FieldDef::_internal_iskey() const {
  return _impl_.iskey_;
}
inline bool FieldDef::iskey() const {
  // @@protoc_insertion_point(field_get:objectstore.FieldDef.isKey)
  return _internal_iskey();
}
inline void FieldDef::_internal_set_iskey(bool value) {
  
  _impl_.iskey_ = value;
}
inline void FieldDef::set_iskey(bool value) {
  _internal_set_iskey(value);
  // @@protoc_insertion_point(field_set:objectstore.FieldDef.isKey)
}

// -------------------------------------------------------------------

// CreateTableResponse

// -------------------------------------------------------------------

// GetTableInfoResponse

// repeated .objectstore.FieldDef fields = 1;
inline int GetTableInfoResponse::_internal_fields_size() const {
  return _impl_.fields_.size();
}
inline int GetTableInfoResponse::fields_size() const {
  return _internal_fields_size();
}
inline void GetTableInfoResponse::clear_fields() {
  _impl_.fields_.Clear();
}
inline ::objectstore::FieldDef* GetTableInfoResponse::mutable_fields(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.GetTableInfoResponse.fields)
  return _impl_.fields_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::FieldDef >*
GetTableInfoResponse::mutable_fields() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.GetTableInfoResponse.fields)
  return &_impl_.fields_;
}
inline const ::objectstore::FieldDef& GetTableInfoResponse::_internal_fields(int index) const {
  return _impl_.fields_.Get(index);
}
inline const ::objectstore::FieldDef& GetTableInfoResponse::fields(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.GetTableInfoResponse.fields)
  return _internal_fields(index);
}
inline ::objectstore::FieldDef* GetTableInfoResponse::_internal_add_fields() {
  return _impl_.fields_.Add();
}
inline ::objectstore::FieldDef* GetTableInfoResponse::add_fields() {
  ::objectstore::FieldDef* _add = _internal_add_fields();
  // @@protoc_insertion_point(field_add:objectstore.GetTableInfoResponse.fields)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::FieldDef >&
GetTableInfoResponse::fields() const {
  // @@protoc_insertion_point(field_list:objectstore.GetTableInfoResponse.fields)
  return _impl_.fields_;
}

// -------------------------------------------------------------------

// TransactionRequest

// .objectstore.StartTransactionRequest startTransaction = 1;
inline bool TransactionRequest::_internal_has_starttransaction() const {
  return payload_case() == kStartTransaction;
}
inline bool TransactionRequest::has_starttransaction() const {
  return _internal_has_starttransaction();
}
inline void TransactionRequest::set_has_starttransaction() {
  _impl_._oneof_case_[0] = kStartTransaction;
}
inline void TransactionRequest::clear_starttransaction() {
  if (_internal_has_starttransaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.starttransaction_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::StartTransactionRequest* TransactionRequest::release_starttransaction() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionRequest.startTransaction)
  if (_internal_has_starttransaction()) {
    clear_has_payload();
    ::objectstore::StartTransactionRequest* temp = _impl_.payload_.starttransaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.starttransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::StartTransactionRequest& TransactionRequest::_internal_starttransaction() const {
  return _internal_has_starttransaction()
      ? *_impl_.payload_.starttransaction_
      : reinterpret_cast< ::objectstore::StartTransactionRequest&>(::objectstore::_StartTransactionRequest_default_instance_);
}
inline const ::objectstore::StartTransactionRequest& TransactionRequest::starttransaction() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionRequest.startTransaction)
  return _internal_starttransaction();
}
inline ::objectstore::StartTransactionRequest* TransactionRequest::unsafe_arena_release_starttransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionRequest.startTransaction)
  if (_internal_has_starttransaction()) {
    clear_has_payload();
    ::objectstore::StartTransactionRequest* temp = _impl_.payload_.starttransaction_;
    _impl_.payload_.starttransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionRequest::unsafe_arena_set_allocated_starttransaction(::objectstore::StartTransactionRequest* starttransaction) {
  clear_payload();
  if (starttransaction) {
    set_has_starttransaction();
    _impl_.payload_.starttransaction_ = starttransaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionRequest.startTransaction)
}
inline ::objectstore::StartTransactionRequest* TransactionRequest::_internal_mutable_starttransaction() {
  if (!_internal_has_starttransaction()) {
    clear_payload();
    set_has_starttransaction();
    _impl_.payload_.starttransaction_ = CreateMaybeMessage< ::objectstore::StartTransactionRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.starttransaction_;
}
inline ::objectstore::StartTransactionRequest* TransactionRequest::mutable_starttransaction() {
  ::objectstore::StartTransactionRequest* _msg = _internal_mutable_starttransaction();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionRequest.startTransaction)
  return _msg;
}

// .objectstore.InsertRowRequest insertRow = 2;
inline bool TransactionRequest::_internal_has_insertrow() const {
  return payload_case() == kInsertRow;
}
inline bool TransactionRequest::has_insertrow() const {
  return _internal_has_insertrow();
}
inline void TransactionRequest::set_has_insertrow() {
  _impl_._oneof_case_[0] = kInsertRow;
}
inline void TransactionRequest::clear_insertrow() {
  if (_internal_has_insertrow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.insertrow_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::InsertRowRequest* TransactionRequest::release_insertrow() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionRequest.insertRow)
  if (_internal_has_insertrow()) {
    clear_has_payload();
    ::objectstore::InsertRowRequest* temp = _impl_.payload_.insertrow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.insertrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::InsertRowRequest& TransactionRequest::_internal_insertrow() const {
  return _internal_has_insertrow()
      ? *_impl_.payload_.insertrow_
      : reinterpret_cast< ::objectstore::InsertRowRequest&>(::objectstore::_InsertRowRequest_default_instance_);
}
inline const ::objectstore::InsertRowRequest& TransactionRequest::insertrow() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionRequest.insertRow)
  return _internal_insertrow();
}
inline ::objectstore::InsertRowRequest* TransactionRequest::unsafe_arena_release_insertrow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionRequest.insertRow)
  if (_internal_has_insertrow()) {
    clear_has_payload();
    ::objectstore::InsertRowRequest* temp = _impl_.payload_.insertrow_;
    _impl_.payload_.insertrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionRequest::unsafe_arena_set_allocated_insertrow(::objectstore::InsertRowRequest* insertrow) {
  clear_payload();
  if (insertrow) {
    set_has_insertrow();
    _impl_.payload_.insertrow_ = insertrow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionRequest.insertRow)
}
inline ::objectstore::InsertRowRequest* TransactionRequest::_internal_mutable_insertrow() {
  if (!_internal_has_insertrow()) {
    clear_payload();
    set_has_insertrow();
    _impl_.payload_.insertrow_ = CreateMaybeMessage< ::objectstore::InsertRowRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.insertrow_;
}
inline ::objectstore::InsertRowRequest* TransactionRequest::mutable_insertrow() {
  ::objectstore::InsertRowRequest* _msg = _internal_mutable_insertrow();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionRequest.insertRow)
  return _msg;
}

// .objectstore.DeleteRowRequest deleteRow = 3;
inline bool TransactionRequest::_internal_has_deleterow() const {
  return payload_case() == kDeleteRow;
}
inline bool TransactionRequest::has_deleterow() const {
  return _internal_has_deleterow();
}
inline void TransactionRequest::set_has_deleterow() {
  _impl_._oneof_case_[0] = kDeleteRow;
}
inline void TransactionRequest::clear_deleterow() {
  if (_internal_has_deleterow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.deleterow_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::DeleteRowRequest* TransactionRequest::release_deleterow() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionRequest.deleteRow)
  if (_internal_has_deleterow()) {
    clear_has_payload();
    ::objectstore::DeleteRowRequest* temp = _impl_.payload_.deleterow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.deleterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::DeleteRowRequest& TransactionRequest::_internal_deleterow() const {
  return _internal_has_deleterow()
      ? *_impl_.payload_.deleterow_
      : reinterpret_cast< ::objectstore::DeleteRowRequest&>(::objectstore::_DeleteRowRequest_default_instance_);
}
inline const ::objectstore::DeleteRowRequest& TransactionRequest::deleterow() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionRequest.deleteRow)
  return _internal_deleterow();
}
inline ::objectstore::DeleteRowRequest* TransactionRequest::unsafe_arena_release_deleterow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionRequest.deleteRow)
  if (_internal_has_deleterow()) {
    clear_has_payload();
    ::objectstore::DeleteRowRequest* temp = _impl_.payload_.deleterow_;
    _impl_.payload_.deleterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionRequest::unsafe_arena_set_allocated_deleterow(::objectstore::DeleteRowRequest* deleterow) {
  clear_payload();
  if (deleterow) {
    set_has_deleterow();
    _impl_.payload_.deleterow_ = deleterow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionRequest.deleteRow)
}
inline ::objectstore::DeleteRowRequest* TransactionRequest::_internal_mutable_deleterow() {
  if (!_internal_has_deleterow()) {
    clear_payload();
    set_has_deleterow();
    _impl_.payload_.deleterow_ = CreateMaybeMessage< ::objectstore::DeleteRowRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.deleterow_;
}
inline ::objectstore::DeleteRowRequest* TransactionRequest::mutable_deleterow() {
  ::objectstore::DeleteRowRequest* _msg = _internal_mutable_deleterow();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionRequest.deleteRow)
  return _msg;
}

// .objectstore.QueryRowsRequest queryRows = 4;
inline bool TransactionRequest::_internal_has_queryrows() const {
  return payload_case() == kQueryRows;
}
inline bool TransactionRequest::has_queryrows() const {
  return _internal_has_queryrows();
}
inline void TransactionRequest::set_has_queryrows() {
  _impl_._oneof_case_[0] = kQueryRows;
}
inline void TransactionRequest::clear_queryrows() {
  if (_internal_has_queryrows()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.queryrows_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::QueryRowsRequest* TransactionRequest::release_queryrows() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionRequest.queryRows)
  if (_internal_has_queryrows()) {
    clear_has_payload();
    ::objectstore::QueryRowsRequest* temp = _impl_.payload_.queryrows_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.queryrows_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::QueryRowsRequest& TransactionRequest::_internal_queryrows() const {
  return _internal_has_queryrows()
      ? *_impl_.payload_.queryrows_
      : reinterpret_cast< ::objectstore::QueryRowsRequest&>(::objectstore::_QueryRowsRequest_default_instance_);
}
inline const ::objectstore::QueryRowsRequest& TransactionRequest::queryrows() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionRequest.queryRows)
  return _internal_queryrows();
}
inline ::objectstore::QueryRowsRequest* TransactionRequest::unsafe_arena_release_queryrows() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionRequest.queryRows)
  if (_internal_has_queryrows()) {
    clear_has_payload();
    ::objectstore::QueryRowsRequest* temp = _impl_.payload_.queryrows_;
    _impl_.payload_.queryrows_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionRequest::unsafe_arena_set_allocated_queryrows(::objectstore::QueryRowsRequest* queryrows) {
  clear_payload();
  if (queryrows) {
    set_has_queryrows();
    _impl_.payload_.queryrows_ = queryrows;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionRequest.queryRows)
}
inline ::objectstore::QueryRowsRequest* TransactionRequest::_internal_mutable_queryrows() {
  if (!_internal_has_queryrows()) {
    clear_payload();
    set_has_queryrows();
    _impl_.payload_.queryrows_ = CreateMaybeMessage< ::objectstore::QueryRowsRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.queryrows_;
}
inline ::objectstore::QueryRowsRequest* TransactionRequest::mutable_queryrows() {
  ::objectstore::QueryRowsRequest* _msg = _internal_mutable_queryrows();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionRequest.queryRows)
  return _msg;
}

// .objectstore.UpdateRowRequest updateRow = 5;
inline bool TransactionRequest::_internal_has_updaterow() const {
  return payload_case() == kUpdateRow;
}
inline bool TransactionRequest::has_updaterow() const {
  return _internal_has_updaterow();
}
inline void TransactionRequest::set_has_updaterow() {
  _impl_._oneof_case_[0] = kUpdateRow;
}
inline void TransactionRequest::clear_updaterow() {
  if (_internal_has_updaterow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.updaterow_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::UpdateRowRequest* TransactionRequest::release_updaterow() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionRequest.updateRow)
  if (_internal_has_updaterow()) {
    clear_has_payload();
    ::objectstore::UpdateRowRequest* temp = _impl_.payload_.updaterow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.updaterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::UpdateRowRequest& TransactionRequest::_internal_updaterow() const {
  return _internal_has_updaterow()
      ? *_impl_.payload_.updaterow_
      : reinterpret_cast< ::objectstore::UpdateRowRequest&>(::objectstore::_UpdateRowRequest_default_instance_);
}
inline const ::objectstore::UpdateRowRequest& TransactionRequest::updaterow() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionRequest.updateRow)
  return _internal_updaterow();
}
inline ::objectstore::UpdateRowRequest* TransactionRequest::unsafe_arena_release_updaterow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionRequest.updateRow)
  if (_internal_has_updaterow()) {
    clear_has_payload();
    ::objectstore::UpdateRowRequest* temp = _impl_.payload_.updaterow_;
    _impl_.payload_.updaterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionRequest::unsafe_arena_set_allocated_updaterow(::objectstore::UpdateRowRequest* updaterow) {
  clear_payload();
  if (updaterow) {
    set_has_updaterow();
    _impl_.payload_.updaterow_ = updaterow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionRequest.updateRow)
}
inline ::objectstore::UpdateRowRequest* TransactionRequest::_internal_mutable_updaterow() {
  if (!_internal_has_updaterow()) {
    clear_payload();
    set_has_updaterow();
    _impl_.payload_.updaterow_ = CreateMaybeMessage< ::objectstore::UpdateRowRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.updaterow_;
}
inline ::objectstore::UpdateRowRequest* TransactionRequest::mutable_updaterow() {
  ::objectstore::UpdateRowRequest* _msg = _internal_mutable_updaterow();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionRequest.updateRow)
  return _msg;
}

// .objectstore.CommitTransactionRequest commitTransaction = 6;
inline bool TransactionRequest::_internal_has_committransaction() const {
  return payload_case() == kCommitTransaction;
}
inline bool TransactionRequest::has_committransaction() const {
  return _internal_has_committransaction();
}
inline void TransactionRequest::set_has_committransaction() {
  _impl_._oneof_case_[0] = kCommitTransaction;
}
inline void TransactionRequest::clear_committransaction() {
  if (_internal_has_committransaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.committransaction_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::CommitTransactionRequest* TransactionRequest::release_committransaction() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionRequest.commitTransaction)
  if (_internal_has_committransaction()) {
    clear_has_payload();
    ::objectstore::CommitTransactionRequest* temp = _impl_.payload_.committransaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.committransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::CommitTransactionRequest& TransactionRequest::_internal_committransaction() const {
  return _internal_has_committransaction()
      ? *_impl_.payload_.committransaction_
      : reinterpret_cast< ::objectstore::CommitTransactionRequest&>(::objectstore::_CommitTransactionRequest_default_instance_);
}
inline const ::objectstore::CommitTransactionRequest& TransactionRequest::committransaction() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionRequest.commitTransaction)
  return _internal_committransaction();
}
inline ::objectstore::CommitTransactionRequest* TransactionRequest::unsafe_arena_release_committransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionRequest.commitTransaction)
  if (_internal_has_committransaction()) {
    clear_has_payload();
    ::objectstore::CommitTransactionRequest* temp = _impl_.payload_.committransaction_;
    _impl_.payload_.committransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionRequest::unsafe_arena_set_allocated_committransaction(::objectstore::CommitTransactionRequest* committransaction) {
  clear_payload();
  if (committransaction) {
    set_has_committransaction();
    _impl_.payload_.committransaction_ = committransaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionRequest.commitTransaction)
}
inline ::objectstore::CommitTransactionRequest* TransactionRequest::_internal_mutable_committransaction() {
  if (!_internal_has_committransaction()) {
    clear_payload();
    set_has_committransaction();
    _impl_.payload_.committransaction_ = CreateMaybeMessage< ::objectstore::CommitTransactionRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.committransaction_;
}
inline ::objectstore::CommitTransactionRequest* TransactionRequest::mutable_committransaction() {
  ::objectstore::CommitTransactionRequest* _msg = _internal_mutable_committransaction();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionRequest.commitTransaction)
  return _msg;
}

// .objectstore.RollbackTransactionRequest rollbackTransaction = 7;
inline bool TransactionRequest::_internal_has_rollbacktransaction() const {
  return payload_case() == kRollbackTransaction;
}
inline bool TransactionRequest::has_rollbacktransaction() const {
  return _internal_has_rollbacktransaction();
}
inline void TransactionRequest::set_has_rollbacktransaction() {
  _impl_._oneof_case_[0] = kRollbackTransaction;
}
inline void TransactionRequest::clear_rollbacktransaction() {
  if (_internal_has_rollbacktransaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rollbacktransaction_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::RollbackTransactionRequest* TransactionRequest::release_rollbacktransaction() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionRequest.rollbackTransaction)
  if (_internal_has_rollbacktransaction()) {
    clear_has_payload();
    ::objectstore::RollbackTransactionRequest* temp = _impl_.payload_.rollbacktransaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rollbacktransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::RollbackTransactionRequest& TransactionRequest::_internal_rollbacktransaction() const {
  return _internal_has_rollbacktransaction()
      ? *_impl_.payload_.rollbacktransaction_
      : reinterpret_cast< ::objectstore::RollbackTransactionRequest&>(::objectstore::_RollbackTransactionRequest_default_instance_);
}
inline const ::objectstore::RollbackTransactionRequest& TransactionRequest::rollbacktransaction() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionRequest.rollbackTransaction)
  return _internal_rollbacktransaction();
}
inline ::objectstore::RollbackTransactionRequest* TransactionRequest::unsafe_arena_release_rollbacktransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionRequest.rollbackTransaction)
  if (_internal_has_rollbacktransaction()) {
    clear_has_payload();
    ::objectstore::RollbackTransactionRequest* temp = _impl_.payload_.rollbacktransaction_;
    _impl_.payload_.rollbacktransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionRequest::unsafe_arena_set_allocated_rollbacktransaction(::objectstore::RollbackTransactionRequest* rollbacktransaction) {
  clear_payload();
  if (rollbacktransaction) {
    set_has_rollbacktransaction();
    _impl_.payload_.rollbacktransaction_ = rollbacktransaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionRequest.rollbackTransaction)
}
inline ::objectstore::RollbackTransactionRequest* TransactionRequest::_internal_mutable_rollbacktransaction() {
  if (!_internal_has_rollbacktransaction()) {
    clear_payload();
    set_has_rollbacktransaction();
    _impl_.payload_.rollbacktransaction_ = CreateMaybeMessage< ::objectstore::RollbackTransactionRequest >(GetArenaForAllocation());
  }
  return _impl_.payload_.rollbacktransaction_;
}
inline ::objectstore::RollbackTransactionRequest* TransactionRequest::mutable_rollbacktransaction() {
  ::objectstore::RollbackTransactionRequest* _msg = _internal_mutable_rollbacktransaction();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionRequest.rollbackTransaction)
  return _msg;
}

inline bool TransactionRequest::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void TransactionRequest::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline TransactionRequest::PayloadCase TransactionRequest::payload_case() const {
  return TransactionRequest::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// TransactionResponse

// .objectstore.StartTransactionResponse startTransaction = 1;
inline bool TransactionResponse::_internal_has_starttransaction() const {
  return payload_case() == kStartTransaction;
}
inline bool TransactionResponse::has_starttransaction() const {
  return _internal_has_starttransaction();
}
inline void TransactionResponse::set_has_starttransaction() {
  _impl_._oneof_case_[0] = kStartTransaction;
}
inline void TransactionResponse::clear_starttransaction() {
  if (_internal_has_starttransaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.starttransaction_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::StartTransactionResponse* TransactionResponse::release_starttransaction() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.startTransaction)
  if (_internal_has_starttransaction()) {
    clear_has_payload();
    ::objectstore::StartTransactionResponse* temp = _impl_.payload_.starttransaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.starttransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::StartTransactionResponse& TransactionResponse::_internal_starttransaction() const {
  return _internal_has_starttransaction()
      ? *_impl_.payload_.starttransaction_
      : reinterpret_cast< ::objectstore::StartTransactionResponse&>(::objectstore::_StartTransactionResponse_default_instance_);
}
inline const ::objectstore::StartTransactionResponse& TransactionResponse::starttransaction() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.startTransaction)
  return _internal_starttransaction();
}
inline ::objectstore::StartTransactionResponse* TransactionResponse::unsafe_arena_release_starttransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.startTransaction)
  if (_internal_has_starttransaction()) {
    clear_has_payload();
    ::objectstore::StartTransactionResponse* temp = _impl_.payload_.starttransaction_;
    _impl_.payload_.starttransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_starttransaction(::objectstore::StartTransactionResponse* starttransaction) {
  clear_payload();
  if (starttransaction) {
    set_has_starttransaction();
    _impl_.payload_.starttransaction_ = starttransaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.startTransaction)
}
inline ::objectstore::StartTransactionResponse* TransactionResponse::_internal_mutable_starttransaction() {
  if (!_internal_has_starttransaction()) {
    clear_payload();
    set_has_starttransaction();
    _impl_.payload_.starttransaction_ = CreateMaybeMessage< ::objectstore::StartTransactionResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.starttransaction_;
}
inline ::objectstore::StartTransactionResponse* TransactionResponse::mutable_starttransaction() {
  ::objectstore::StartTransactionResponse* _msg = _internal_mutable_starttransaction();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.startTransaction)
  return _msg;
}

// .objectstore.InsertRowResponse insertRow = 2;
inline bool TransactionResponse::_internal_has_insertrow() const {
  return payload_case() == kInsertRow;
}
inline bool TransactionResponse::has_insertrow() const {
  return _internal_has_insertrow();
}
inline void TransactionResponse::set_has_insertrow() {
  _impl_._oneof_case_[0] = kInsertRow;
}
inline void TransactionResponse::clear_insertrow() {
  if (_internal_has_insertrow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.insertrow_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::InsertRowResponse* TransactionResponse::release_insertrow() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.insertRow)
  if (_internal_has_insertrow()) {
    clear_has_payload();
    ::objectstore::InsertRowResponse* temp = _impl_.payload_.insertrow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.insertrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::InsertRowResponse& TransactionResponse::_internal_insertrow() const {
  return _internal_has_insertrow()
      ? *_impl_.payload_.insertrow_
      : reinterpret_cast< ::objectstore::InsertRowResponse&>(::objectstore::_InsertRowResponse_default_instance_);
}
inline const ::objectstore::InsertRowResponse& TransactionResponse::insertrow() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.insertRow)
  return _internal_insertrow();
}
inline ::objectstore::InsertRowResponse* TransactionResponse::unsafe_arena_release_insertrow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.insertRow)
  if (_internal_has_insertrow()) {
    clear_has_payload();
    ::objectstore::InsertRowResponse* temp = _impl_.payload_.insertrow_;
    _impl_.payload_.insertrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_insertrow(::objectstore::InsertRowResponse* insertrow) {
  clear_payload();
  if (insertrow) {
    set_has_insertrow();
    _impl_.payload_.insertrow_ = insertrow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.insertRow)
}
inline ::objectstore::InsertRowResponse* TransactionResponse::_internal_mutable_insertrow() {
  if (!_internal_has_insertrow()) {
    clear_payload();
    set_has_insertrow();
    _impl_.payload_.insertrow_ = CreateMaybeMessage< ::objectstore::InsertRowResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.insertrow_;
}
inline ::objectstore::InsertRowResponse* TransactionResponse::mutable_insertrow() {
  ::objectstore::InsertRowResponse* _msg = _internal_mutable_insertrow();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.insertRow)
  return _msg;
}

// .objectstore.DeleteRowResponse deleteRow = 3;
inline bool TransactionResponse::_internal_has_deleterow() const {
  return payload_case() == kDeleteRow;
}
inline bool TransactionResponse::has_deleterow() const {
  return _internal_has_deleterow();
}
inline void TransactionResponse::set_has_deleterow() {
  _impl_._oneof_case_[0] = kDeleteRow;
}
inline void TransactionResponse::clear_deleterow() {
  if (_internal_has_deleterow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.deleterow_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::DeleteRowResponse* TransactionResponse::release_deleterow() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.deleteRow)
  if (_internal_has_deleterow()) {
    clear_has_payload();
    ::objectstore::DeleteRowResponse* temp = _impl_.payload_.deleterow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.deleterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::DeleteRowResponse& TransactionResponse::_internal_deleterow() const {
  return _internal_has_deleterow()
      ? *_impl_.payload_.deleterow_
      : reinterpret_cast< ::objectstore::DeleteRowResponse&>(::objectstore::_DeleteRowResponse_default_instance_);
}
inline const ::objectstore::DeleteRowResponse& TransactionResponse::deleterow() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.deleteRow)
  return _internal_deleterow();
}
inline ::objectstore::DeleteRowResponse* TransactionResponse::unsafe_arena_release_deleterow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.deleteRow)
  if (_internal_has_deleterow()) {
    clear_has_payload();
    ::objectstore::DeleteRowResponse* temp = _impl_.payload_.deleterow_;
    _impl_.payload_.deleterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_deleterow(::objectstore::DeleteRowResponse* deleterow) {
  clear_payload();
  if (deleterow) {
    set_has_deleterow();
    _impl_.payload_.deleterow_ = deleterow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.deleteRow)
}
inline ::objectstore::DeleteRowResponse* TransactionResponse::_internal_mutable_deleterow() {
  if (!_internal_has_deleterow()) {
    clear_payload();
    set_has_deleterow();
    _impl_.payload_.deleterow_ = CreateMaybeMessage< ::objectstore::DeleteRowResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.deleterow_;
}
inline ::objectstore::DeleteRowResponse* TransactionResponse::mutable_deleterow() {
  ::objectstore::DeleteRowResponse* _msg = _internal_mutable_deleterow();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.deleteRow)
  return _msg;
}

// .objectstore.QueryRowResponse queryRows = 4;
inline bool TransactionResponse::_internal_has_queryrows() const {
  return payload_case() == kQueryRows;
}
inline bool TransactionResponse::has_queryrows() const {
  return _internal_has_queryrows();
}
inline void TransactionResponse::set_has_queryrows() {
  _impl_._oneof_case_[0] = kQueryRows;
}
inline void TransactionResponse::clear_queryrows() {
  if (_internal_has_queryrows()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.queryrows_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::QueryRowResponse* TransactionResponse::release_queryrows() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.queryRows)
  if (_internal_has_queryrows()) {
    clear_has_payload();
    ::objectstore::QueryRowResponse* temp = _impl_.payload_.queryrows_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.queryrows_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::QueryRowResponse& TransactionResponse::_internal_queryrows() const {
  return _internal_has_queryrows()
      ? *_impl_.payload_.queryrows_
      : reinterpret_cast< ::objectstore::QueryRowResponse&>(::objectstore::_QueryRowResponse_default_instance_);
}
inline const ::objectstore::QueryRowResponse& TransactionResponse::queryrows() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.queryRows)
  return _internal_queryrows();
}
inline ::objectstore::QueryRowResponse* TransactionResponse::unsafe_arena_release_queryrows() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.queryRows)
  if (_internal_has_queryrows()) {
    clear_has_payload();
    ::objectstore::QueryRowResponse* temp = _impl_.payload_.queryrows_;
    _impl_.payload_.queryrows_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_queryrows(::objectstore::QueryRowResponse* queryrows) {
  clear_payload();
  if (queryrows) {
    set_has_queryrows();
    _impl_.payload_.queryrows_ = queryrows;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.queryRows)
}
inline ::objectstore::QueryRowResponse* TransactionResponse::_internal_mutable_queryrows() {
  if (!_internal_has_queryrows()) {
    clear_payload();
    set_has_queryrows();
    _impl_.payload_.queryrows_ = CreateMaybeMessage< ::objectstore::QueryRowResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.queryrows_;
}
inline ::objectstore::QueryRowResponse* TransactionResponse::mutable_queryrows() {
  ::objectstore::QueryRowResponse* _msg = _internal_mutable_queryrows();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.queryRows)
  return _msg;
}

// .objectstore.UpdateRowResponse updateRow = 5;
inline bool TransactionResponse::_internal_has_updaterow() const {
  return payload_case() == kUpdateRow;
}
inline bool TransactionResponse::has_updaterow() const {
  return _internal_has_updaterow();
}
inline void TransactionResponse::set_has_updaterow() {
  _impl_._oneof_case_[0] = kUpdateRow;
}
inline void TransactionResponse::clear_updaterow() {
  if (_internal_has_updaterow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.updaterow_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::UpdateRowResponse* TransactionResponse::release_updaterow() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.updateRow)
  if (_internal_has_updaterow()) {
    clear_has_payload();
    ::objectstore::UpdateRowResponse* temp = _impl_.payload_.updaterow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.updaterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::UpdateRowResponse& TransactionResponse::_internal_updaterow() const {
  return _internal_has_updaterow()
      ? *_impl_.payload_.updaterow_
      : reinterpret_cast< ::objectstore::UpdateRowResponse&>(::objectstore::_UpdateRowResponse_default_instance_);
}
inline const ::objectstore::UpdateRowResponse& TransactionResponse::updaterow() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.updateRow)
  return _internal_updaterow();
}
inline ::objectstore::UpdateRowResponse* TransactionResponse::unsafe_arena_release_updaterow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.updateRow)
  if (_internal_has_updaterow()) {
    clear_has_payload();
    ::objectstore::UpdateRowResponse* temp = _impl_.payload_.updaterow_;
    _impl_.payload_.updaterow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_updaterow(::objectstore::UpdateRowResponse* updaterow) {
  clear_payload();
  if (updaterow) {
    set_has_updaterow();
    _impl_.payload_.updaterow_ = updaterow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.updateRow)
}
inline ::objectstore::UpdateRowResponse* TransactionResponse::_internal_mutable_updaterow() {
  if (!_internal_has_updaterow()) {
    clear_payload();
    set_has_updaterow();
    _impl_.payload_.updaterow_ = CreateMaybeMessage< ::objectstore::UpdateRowResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.updaterow_;
}
inline ::objectstore::UpdateRowResponse* TransactionResponse::mutable_updaterow() {
  ::objectstore::UpdateRowResponse* _msg = _internal_mutable_updaterow();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.updateRow)
  return _msg;
}

// .objectstore.CommitTransactionResponse commitTransaction = 6;
inline bool TransactionResponse::_internal_has_committransaction() const {
  return payload_case() == kCommitTransaction;
}
inline bool TransactionResponse::has_committransaction() const {
  return _internal_has_committransaction();
}
inline void TransactionResponse::set_has_committransaction() {
  _impl_._oneof_case_[0] = kCommitTransaction;
}
inline void TransactionResponse::clear_committransaction() {
  if (_internal_has_committransaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.committransaction_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::CommitTransactionResponse* TransactionResponse::release_committransaction() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.commitTransaction)
  if (_internal_has_committransaction()) {
    clear_has_payload();
    ::objectstore::CommitTransactionResponse* temp = _impl_.payload_.committransaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.committransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::CommitTransactionResponse& TransactionResponse::_internal_committransaction() const {
  return _internal_has_committransaction()
      ? *_impl_.payload_.committransaction_
      : reinterpret_cast< ::objectstore::CommitTransactionResponse&>(::objectstore::_CommitTransactionResponse_default_instance_);
}
inline const ::objectstore::CommitTransactionResponse& TransactionResponse::committransaction() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.commitTransaction)
  return _internal_committransaction();
}
inline ::objectstore::CommitTransactionResponse* TransactionResponse::unsafe_arena_release_committransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.commitTransaction)
  if (_internal_has_committransaction()) {
    clear_has_payload();
    ::objectstore::CommitTransactionResponse* temp = _impl_.payload_.committransaction_;
    _impl_.payload_.committransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_committransaction(::objectstore::CommitTransactionResponse* committransaction) {
  clear_payload();
  if (committransaction) {
    set_has_committransaction();
    _impl_.payload_.committransaction_ = committransaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.commitTransaction)
}
inline ::objectstore::CommitTransactionResponse* TransactionResponse::_internal_mutable_committransaction() {
  if (!_internal_has_committransaction()) {
    clear_payload();
    set_has_committransaction();
    _impl_.payload_.committransaction_ = CreateMaybeMessage< ::objectstore::CommitTransactionResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.committransaction_;
}
inline ::objectstore::CommitTransactionResponse* TransactionResponse::mutable_committransaction() {
  ::objectstore::CommitTransactionResponse* _msg = _internal_mutable_committransaction();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.commitTransaction)
  return _msg;
}

// .objectstore.RollbackTransactionResponse rollbackTransaction = 7;
inline bool TransactionResponse::_internal_has_rollbacktransaction() const {
  return payload_case() == kRollbackTransaction;
}
inline bool TransactionResponse::has_rollbacktransaction() const {
  return _internal_has_rollbacktransaction();
}
inline void TransactionResponse::set_has_rollbacktransaction() {
  _impl_._oneof_case_[0] = kRollbackTransaction;
}
inline void TransactionResponse::clear_rollbacktransaction() {
  if (_internal_has_rollbacktransaction()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.rollbacktransaction_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::RollbackTransactionResponse* TransactionResponse::release_rollbacktransaction() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.rollbackTransaction)
  if (_internal_has_rollbacktransaction()) {
    clear_has_payload();
    ::objectstore::RollbackTransactionResponse* temp = _impl_.payload_.rollbacktransaction_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.rollbacktransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::RollbackTransactionResponse& TransactionResponse::_internal_rollbacktransaction() const {
  return _internal_has_rollbacktransaction()
      ? *_impl_.payload_.rollbacktransaction_
      : reinterpret_cast< ::objectstore::RollbackTransactionResponse&>(::objectstore::_RollbackTransactionResponse_default_instance_);
}
inline const ::objectstore::RollbackTransactionResponse& TransactionResponse::rollbacktransaction() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.rollbackTransaction)
  return _internal_rollbacktransaction();
}
inline ::objectstore::RollbackTransactionResponse* TransactionResponse::unsafe_arena_release_rollbacktransaction() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.rollbackTransaction)
  if (_internal_has_rollbacktransaction()) {
    clear_has_payload();
    ::objectstore::RollbackTransactionResponse* temp = _impl_.payload_.rollbacktransaction_;
    _impl_.payload_.rollbacktransaction_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_rollbacktransaction(::objectstore::RollbackTransactionResponse* rollbacktransaction) {
  clear_payload();
  if (rollbacktransaction) {
    set_has_rollbacktransaction();
    _impl_.payload_.rollbacktransaction_ = rollbacktransaction;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.rollbackTransaction)
}
inline ::objectstore::RollbackTransactionResponse* TransactionResponse::_internal_mutable_rollbacktransaction() {
  if (!_internal_has_rollbacktransaction()) {
    clear_payload();
    set_has_rollbacktransaction();
    _impl_.payload_.rollbacktransaction_ = CreateMaybeMessage< ::objectstore::RollbackTransactionResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.rollbacktransaction_;
}
inline ::objectstore::RollbackTransactionResponse* TransactionResponse::mutable_rollbacktransaction() {
  ::objectstore::RollbackTransactionResponse* _msg = _internal_mutable_rollbacktransaction();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.rollbackTransaction)
  return _msg;
}

// .objectstore.ErrorResponse error = 8;
inline bool TransactionResponse::_internal_has_error() const {
  return payload_case() == kError;
}
inline bool TransactionResponse::has_error() const {
  return _internal_has_error();
}
inline void TransactionResponse::set_has_error() {
  _impl_._oneof_case_[0] = kError;
}
inline void TransactionResponse::clear_error() {
  if (_internal_has_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.payload_.error_;
    }
    clear_has_payload();
  }
}
inline ::objectstore::ErrorResponse* TransactionResponse::release_error() {
  // @@protoc_insertion_point(field_release:objectstore.TransactionResponse.error)
  if (_internal_has_error()) {
    clear_has_payload();
    ::objectstore::ErrorResponse* temp = _impl_.payload_.error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::objectstore::ErrorResponse& TransactionResponse::_internal_error() const {
  return _internal_has_error()
      ? *_impl_.payload_.error_
      : reinterpret_cast< ::objectstore::ErrorResponse&>(::objectstore::_ErrorResponse_default_instance_);
}
inline const ::objectstore::ErrorResponse& TransactionResponse::error() const {
  // @@protoc_insertion_point(field_get:objectstore.TransactionResponse.error)
  return _internal_error();
}
inline ::objectstore::ErrorResponse* TransactionResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:objectstore.TransactionResponse.error)
  if (_internal_has_error()) {
    clear_has_payload();
    ::objectstore::ErrorResponse* temp = _impl_.payload_.error_;
    _impl_.payload_.error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TransactionResponse::unsafe_arena_set_allocated_error(::objectstore::ErrorResponse* error) {
  clear_payload();
  if (error) {
    set_has_error();
    _impl_.payload_.error_ = error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.TransactionResponse.error)
}
inline ::objectstore::ErrorResponse* TransactionResponse::_internal_mutable_error() {
  if (!_internal_has_error()) {
    clear_payload();
    set_has_error();
    _impl_.payload_.error_ = CreateMaybeMessage< ::objectstore::ErrorResponse >(GetArenaForAllocation());
  }
  return _impl_.payload_.error_;
}
inline ::objectstore::ErrorResponse* TransactionResponse::mutable_error() {
  ::objectstore::ErrorResponse* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:objectstore.TransactionResponse.error)
  return _msg;
}

inline bool TransactionResponse::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void TransactionResponse::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline TransactionResponse::PayloadCase TransactionResponse::payload_case() const {
  return TransactionResponse::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// FieldData

// int64 intMember = 1;
inline bool FieldData::_internal_has_intmember() const {
  return payload_case() == kIntMember;
}
inline bool FieldData::has_intmember() const {
  return _internal_has_intmember();
}
inline void FieldData::set_has_intmember() {
  _impl_._oneof_case_[0] = kIntMember;
}
inline void FieldData::clear_intmember() {
  if (_internal_has_intmember()) {
    _impl_.payload_.intmember_ = int64_t{0};
    clear_has_payload();
  }
}
inline int64_t FieldData::_internal_intmember() const {
  if (_internal_has_intmember()) {
    return _impl_.payload_.intmember_;
  }
  return int64_t{0};
}
inline void FieldData::_internal_set_intmember(int64_t value) {
  if (!_internal_has_intmember()) {
    clear_payload();
    set_has_intmember();
  }
  _impl_.payload_.intmember_ = value;
}
inline int64_t FieldData::intmember() const {
  // @@protoc_insertion_point(field_get:objectstore.FieldData.intMember)
  return _internal_intmember();
}
inline void FieldData::set_intmember(int64_t value) {
  _internal_set_intmember(value);
  // @@protoc_insertion_point(field_set:objectstore.FieldData.intMember)
}

// double floatMember = 2;
inline bool FieldData::_internal_has_floatmember() const {
  return payload_case() == kFloatMember;
}
inline bool FieldData::has_floatmember() const {
  return _internal_has_floatmember();
}
inline void FieldData::set_has_floatmember() {
  _impl_._oneof_case_[0] = kFloatMember;
}
inline void FieldData::clear_floatmember() {
  if (_internal_has_floatmember()) {
    _impl_.payload_.floatmember_ = 0;
    clear_has_payload();
  }
}
inline double FieldData::_internal_floatmember() const {
  if (_internal_has_floatmember()) {
    return _impl_.payload_.floatmember_;
  }
  return 0;
}
inline void FieldData::_internal_set_floatmember(double value) {
  if (!_internal_has_floatmember()) {
    clear_payload();
    set_has_floatmember();
  }
  _impl_.payload_.floatmember_ = value;
}
inline double FieldData::floatmember() const {
  // @@protoc_insertion_point(field_get:objectstore.FieldData.floatMember)
  return _internal_floatmember();
}
inline void FieldData::set_floatmember(double value) {
  _internal_set_floatmember(value);
  // @@protoc_insertion_point(field_set:objectstore.FieldData.floatMember)
}

// bool boolMember = 3;
inline bool FieldData::_internal_has_boolmember() const {
  return payload_case() == kBoolMember;
}
inline bool FieldData::has_boolmember() const {
  return _internal_has_boolmember();
}
inline void FieldData::set_has_boolmember() {
  _impl_._oneof_case_[0] = kBoolMember;
}
inline void FieldData::clear_boolmember() {
  if (_internal_has_boolmember()) {
    _impl_.payload_.boolmember_ = false;
    clear_has_payload();
  }
}
inline bool FieldData::_internal_boolmember() const {
  if (_internal_has_boolmember()) {
    return _impl_.payload_.boolmember_;
  }
  return false;
}
inline void FieldData::_internal_set_boolmember(bool value) {
  if (!_internal_has_boolmember()) {
    clear_payload();
    set_has_boolmember();
  }
  _impl_.payload_.boolmember_ = value;
}
inline bool FieldData::boolmember() const {
  // @@protoc_insertion_point(field_get:objectstore.FieldData.boolMember)
  return _internal_boolmember();
}
inline void FieldData::set_boolmember(bool value) {
  _internal_set_boolmember(value);
  // @@protoc_insertion_point(field_set:objectstore.FieldData.boolMember)
}

// string stringMember = 4;
inline bool FieldData::_internal_has_stringmember() const {
  return payload_case() == kStringMember;
}
inline bool FieldData::has_stringmember() const {
  return _internal_has_stringmember();
}
inline void FieldData::set_has_stringmember() {
  _impl_._oneof_case_[0] = kStringMember;
}
inline void FieldData::clear_stringmember() {
  if (_internal_has_stringmember()) {
    _impl_.payload_.stringmember_.Destroy();
    clear_has_payload();
  }
}
inline const std::string& FieldData::stringmember() const {
  // @@protoc_insertion_point(field_get:objectstore.FieldData.stringMember)
  return _internal_stringmember();
}
template <typename ArgT0, typename... ArgT>
inline void FieldData::set_stringmember(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_stringmember()) {
    clear_payload();
    set_has_stringmember();
    _impl_.payload_.stringmember_.InitDefault();
  }
  _impl_.payload_.stringmember_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:objectstore.FieldData.stringMember)
}
inline std::string* FieldData::mutable_stringmember() {
  std::string* _s = _internal_mutable_stringmember();
  // @@protoc_insertion_point(field_mutable:objectstore.FieldData.stringMember)
  return _s;
}
inline const std::string& FieldData::_internal_stringmember() const {
  if (_internal_has_stringmember()) {
    return _impl_.payload_.stringmember_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void FieldData::_internal_set_stringmember(const std::string& value) {
  if (!_internal_has_stringmember()) {
    clear_payload();
    set_has_stringmember();
    _impl_.payload_.stringmember_.InitDefault();
  }
  _impl_.payload_.stringmember_.Set(value, GetArenaForAllocation());
}
inline std::string* FieldData::_internal_mutable_stringmember() {
  if (!_internal_has_stringmember()) {
    clear_payload();
    set_has_stringmember();
    _impl_.payload_.stringmember_.InitDefault();
  }
  return _impl_.payload_.stringmember_.Mutable(      GetArenaForAllocation());
}
inline std::string* FieldData::release_stringmember() {
  // @@protoc_insertion_point(field_release:objectstore.FieldData.stringMember)
  if (_internal_has_stringmember()) {
    clear_has_payload();
    return _impl_.payload_.stringmember_.Release();
  } else {
    return nullptr;
  }
}
inline void FieldData::set_allocated_stringmember(std::string* stringmember) {
  if (has_payload()) {
    clear_payload();
  }
  if (stringmember != nullptr) {
    set_has_stringmember();
    _impl_.payload_.stringmember_.InitAllocated(stringmember, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:objectstore.FieldData.stringMember)
}

inline bool FieldData::has_payload() const {
  return payload_case() != PAYLOAD_NOT_SET;
}
inline void FieldData::clear_has_payload() {
  _impl_._oneof_case_[0] = PAYLOAD_NOT_SET;
}
inline FieldData::PayloadCase FieldData::payload_case() const {
  return FieldData::PayloadCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Field

// string name = 1;
inline void Field::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Field::name() const {
  // @@protoc_insertion_point(field_get:objectstore.Field.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Field::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:objectstore.Field.name)
}
inline std::string* Field::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:objectstore.Field.name)
  return _s;
}
inline const std::string& Field::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Field::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Field::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Field::release_name() {
  // @@protoc_insertion_point(field_release:objectstore.Field.name)
  return _impl_.name_.Release();
}
inline void Field::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:objectstore.Field.name)
}

// .objectstore.FieldType type = 2;
inline void Field::clear_type() {
  _impl_.type_ = 0;
}
inline ::objectstore::FieldType Field::_internal_type() const {
  return static_cast< ::objectstore::FieldType >(_impl_.type_);
}
inline ::objectstore::FieldType Field::type() const {
  // @@protoc_insertion_point(field_get:objectstore.Field.type)
  return _internal_type();
}
inline void Field::_internal_set_type(::objectstore::FieldType value) {
  
  _impl_.type_ = value;
}
inline void Field::set_type(::objectstore::FieldType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:objectstore.Field.type)
}

// .objectstore.FieldData data = 3;
inline bool Field::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool Field::has_data() const {
  return _internal_has_data();
}
inline void Field::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::objectstore::FieldData& Field::_internal_data() const {
  const ::objectstore::FieldData* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::objectstore::FieldData&>(
      ::objectstore::_FieldData_default_instance_);
}
inline const ::objectstore::FieldData& Field::data() const {
  // @@protoc_insertion_point(field_get:objectstore.Field.data)
  return _internal_data();
}
inline void Field::unsafe_arena_set_allocated_data(
    ::objectstore::FieldData* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:objectstore.Field.data)
}
inline ::objectstore::FieldData* Field::release_data() {
  
  ::objectstore::FieldData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::objectstore::FieldData* Field::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:objectstore.Field.data)
  
  ::objectstore::FieldData* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::objectstore::FieldData* Field::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::objectstore::FieldData>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::objectstore::FieldData* Field::mutable_data() {
  ::objectstore::FieldData* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:objectstore.Field.data)
  return _msg;
}
inline void Field::set_allocated_data(::objectstore::FieldData* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:objectstore.Field.data)
}

// -------------------------------------------------------------------

// StartTransactionRequest

// string tableName = 1;
inline void StartTransactionRequest::clear_tablename() {
  _impl_.tablename_.ClearToEmpty();
}
inline const std::string& StartTransactionRequest::tablename() const {
  // @@protoc_insertion_point(field_get:objectstore.StartTransactionRequest.tableName)
  return _internal_tablename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StartTransactionRequest::set_tablename(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tablename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:objectstore.StartTransactionRequest.tableName)
}
inline std::string* StartTransactionRequest::mutable_tablename() {
  std::string* _s = _internal_mutable_tablename();
  // @@protoc_insertion_point(field_mutable:objectstore.StartTransactionRequest.tableName)
  return _s;
}
inline const std::string& StartTransactionRequest::_internal_tablename() const {
  return _impl_.tablename_.Get();
}
inline void StartTransactionRequest::_internal_set_tablename(const std::string& value) {
  
  _impl_.tablename_.Set(value, GetArenaForAllocation());
}
inline std::string* StartTransactionRequest::_internal_mutable_tablename() {
  
  return _impl_.tablename_.Mutable(GetArenaForAllocation());
}
inline std::string* StartTransactionRequest::release_tablename() {
  // @@protoc_insertion_point(field_release:objectstore.StartTransactionRequest.tableName)
  return _impl_.tablename_.Release();
}
inline void StartTransactionRequest::set_allocated_tablename(std::string* tablename) {
  if (tablename != nullptr) {
    
  } else {
    
  }
  _impl_.tablename_.SetAllocated(tablename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tablename_.IsDefault()) {
    _impl_.tablename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:objectstore.StartTransactionRequest.tableName)
}

// bool writable = 2;
inline void StartTransactionRequest::clear_writable() {
  _impl_.writable_ = false;
}
inline bool StartTransactionRequest::_internal_writable() const {
  return _impl_.writable_;
}
inline bool StartTransactionRequest::writable() const {
  // @@protoc_insertion_point(field_get:objectstore.StartTransactionRequest.writable)
  return _internal_writable();
}
inline void StartTransactionRequest::_internal_set_writable(bool value) {
  
  _impl_.writable_ = value;
}
inline void StartTransactionRequest::set_writable(bool value) {
  _internal_set_writable(value);
  // @@protoc_insertion_point(field_set:objectstore.StartTransactionRequest.writable)
}

// -------------------------------------------------------------------

// StartTransactionResponse

// -------------------------------------------------------------------

// CommitTransactionRequest

// -------------------------------------------------------------------

// CommitTransactionResponse

// -------------------------------------------------------------------

// RollbackTransactionRequest

// -------------------------------------------------------------------

// RollbackTransactionResponse

// -------------------------------------------------------------------

// InsertRowRequest

// repeated .objectstore.Field value = 1;
inline int InsertRowRequest::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int InsertRowRequest::value_size() const {
  return _internal_value_size();
}
inline void InsertRowRequest::clear_value() {
  _impl_.value_.Clear();
}
inline ::objectstore::Field* InsertRowRequest::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.InsertRowRequest.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
InsertRowRequest::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.InsertRowRequest.value)
  return &_impl_.value_;
}
inline const ::objectstore::Field& InsertRowRequest::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::objectstore::Field& InsertRowRequest::value(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.InsertRowRequest.value)
  return _internal_value(index);
}
inline ::objectstore::Field* InsertRowRequest::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::objectstore::Field* InsertRowRequest::add_value() {
  ::objectstore::Field* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:objectstore.InsertRowRequest.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
InsertRowRequest::value() const {
  // @@protoc_insertion_point(field_list:objectstore.InsertRowRequest.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// InsertRowResponse

// -------------------------------------------------------------------

// DeleteRowRequest

// repeated .objectstore.Field conditions = 1;
inline int DeleteRowRequest::_internal_conditions_size() const {
  return _impl_.conditions_.size();
}
inline int DeleteRowRequest::conditions_size() const {
  return _internal_conditions_size();
}
inline void DeleteRowRequest::clear_conditions() {
  _impl_.conditions_.Clear();
}
inline ::objectstore::Field* DeleteRowRequest::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.DeleteRowRequest.conditions)
  return _impl_.conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
DeleteRowRequest::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.DeleteRowRequest.conditions)
  return &_impl_.conditions_;
}
inline const ::objectstore::Field& DeleteRowRequest::_internal_conditions(int index) const {
  return _impl_.conditions_.Get(index);
}
inline const ::objectstore::Field& DeleteRowRequest::conditions(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.DeleteRowRequest.conditions)
  return _internal_conditions(index);
}
inline ::objectstore::Field* DeleteRowRequest::_internal_add_conditions() {
  return _impl_.conditions_.Add();
}
inline ::objectstore::Field* DeleteRowRequest::add_conditions() {
  ::objectstore::Field* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:objectstore.DeleteRowRequest.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
DeleteRowRequest::conditions() const {
  // @@protoc_insertion_point(field_list:objectstore.DeleteRowRequest.conditions)
  return _impl_.conditions_;
}

// -------------------------------------------------------------------

// DeleteRowResponse

// -------------------------------------------------------------------

// QueryRowsRequest

// repeated .objectstore.Field conditions = 1;
inline int QueryRowsRequest::_internal_conditions_size() const {
  return _impl_.conditions_.size();
}
inline int QueryRowsRequest::conditions_size() const {
  return _internal_conditions_size();
}
inline void QueryRowsRequest::clear_conditions() {
  _impl_.conditions_.Clear();
}
inline ::objectstore::Field* QueryRowsRequest::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.QueryRowsRequest.conditions)
  return _impl_.conditions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
QueryRowsRequest::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.QueryRowsRequest.conditions)
  return &_impl_.conditions_;
}
inline const ::objectstore::Field& QueryRowsRequest::_internal_conditions(int index) const {
  return _impl_.conditions_.Get(index);
}
inline const ::objectstore::Field& QueryRowsRequest::conditions(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.QueryRowsRequest.conditions)
  return _internal_conditions(index);
}
inline ::objectstore::Field* QueryRowsRequest::_internal_add_conditions() {
  return _impl_.conditions_.Add();
}
inline ::objectstore::Field* QueryRowsRequest::add_conditions() {
  ::objectstore::Field* _add = _internal_add_conditions();
  // @@protoc_insertion_point(field_add:objectstore.QueryRowsRequest.conditions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
QueryRowsRequest::conditions() const {
  // @@protoc_insertion_point(field_list:objectstore.QueryRowsRequest.conditions)
  return _impl_.conditions_;
}

// -------------------------------------------------------------------

// QueryRowResponse

// repeated .objectstore.Field key = 1;
inline int QueryRowResponse::_internal_key_size() const {
  return _impl_.key_.size();
}
inline int QueryRowResponse::key_size() const {
  return _internal_key_size();
}
inline void QueryRowResponse::clear_key() {
  _impl_.key_.Clear();
}
inline ::objectstore::Field* QueryRowResponse::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.QueryRowResponse.key)
  return _impl_.key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
QueryRowResponse::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.QueryRowResponse.key)
  return &_impl_.key_;
}
inline const ::objectstore::Field& QueryRowResponse::_internal_key(int index) const {
  return _impl_.key_.Get(index);
}
inline const ::objectstore::Field& QueryRowResponse::key(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.QueryRowResponse.key)
  return _internal_key(index);
}
inline ::objectstore::Field* QueryRowResponse::_internal_add_key() {
  return _impl_.key_.Add();
}
inline ::objectstore::Field* QueryRowResponse::add_key() {
  ::objectstore::Field* _add = _internal_add_key();
  // @@protoc_insertion_point(field_add:objectstore.QueryRowResponse.key)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
QueryRowResponse::key() const {
  // @@protoc_insertion_point(field_list:objectstore.QueryRowResponse.key)
  return _impl_.key_;
}

// repeated .objectstore.Field value = 2;
inline int QueryRowResponse::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int QueryRowResponse::value_size() const {
  return _internal_value_size();
}
inline void QueryRowResponse::clear_value() {
  _impl_.value_.Clear();
}
inline ::objectstore::Field* QueryRowResponse::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.QueryRowResponse.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
QueryRowResponse::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.QueryRowResponse.value)
  return &_impl_.value_;
}
inline const ::objectstore::Field& QueryRowResponse::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::objectstore::Field& QueryRowResponse::value(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.QueryRowResponse.value)
  return _internal_value(index);
}
inline ::objectstore::Field* QueryRowResponse::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::objectstore::Field* QueryRowResponse::add_value() {
  ::objectstore::Field* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:objectstore.QueryRowResponse.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
QueryRowResponse::value() const {
  // @@protoc_insertion_point(field_list:objectstore.QueryRowResponse.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// UpdateRowRequest

// repeated .objectstore.Field key = 1;
inline int UpdateRowRequest::_internal_key_size() const {
  return _impl_.key_.size();
}
inline int UpdateRowRequest::key_size() const {
  return _internal_key_size();
}
inline void UpdateRowRequest::clear_key() {
  _impl_.key_.Clear();
}
inline ::objectstore::Field* UpdateRowRequest::mutable_key(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.UpdateRowRequest.key)
  return _impl_.key_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
UpdateRowRequest::mutable_key() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.UpdateRowRequest.key)
  return &_impl_.key_;
}
inline const ::objectstore::Field& UpdateRowRequest::_internal_key(int index) const {
  return _impl_.key_.Get(index);
}
inline const ::objectstore::Field& UpdateRowRequest::key(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.UpdateRowRequest.key)
  return _internal_key(index);
}
inline ::objectstore::Field* UpdateRowRequest::_internal_add_key() {
  return _impl_.key_.Add();
}
inline ::objectstore::Field* UpdateRowRequest::add_key() {
  ::objectstore::Field* _add = _internal_add_key();
  // @@protoc_insertion_point(field_add:objectstore.UpdateRowRequest.key)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
UpdateRowRequest::key() const {
  // @@protoc_insertion_point(field_list:objectstore.UpdateRowRequest.key)
  return _impl_.key_;
}

// repeated .objectstore.Field value = 2;
inline int UpdateRowRequest::_internal_value_size() const {
  return _impl_.value_.size();
}
inline int UpdateRowRequest::value_size() const {
  return _internal_value_size();
}
inline void UpdateRowRequest::clear_value() {
  _impl_.value_.Clear();
}
inline ::objectstore::Field* UpdateRowRequest::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:objectstore.UpdateRowRequest.value)
  return _impl_.value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >*
UpdateRowRequest::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:objectstore.UpdateRowRequest.value)
  return &_impl_.value_;
}
inline const ::objectstore::Field& UpdateRowRequest::_internal_value(int index) const {
  return _impl_.value_.Get(index);
}
inline const ::objectstore::Field& UpdateRowRequest::value(int index) const {
  // @@protoc_insertion_point(field_get:objectstore.UpdateRowRequest.value)
  return _internal_value(index);
}
inline ::objectstore::Field* UpdateRowRequest::_internal_add_value() {
  return _impl_.value_.Add();
}
inline ::objectstore::Field* UpdateRowRequest::add_value() {
  ::objectstore::Field* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:objectstore.UpdateRowRequest.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::objectstore::Field >&
UpdateRowRequest::value() const {
  // @@protoc_insertion_point(field_list:objectstore.UpdateRowRequest.value)
  return _impl_.value_;
}

// -------------------------------------------------------------------

// UpdateRowResponse

// -------------------------------------------------------------------

// ErrorResponse

// string message = 1;
inline void ErrorResponse::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& ErrorResponse::message() const {
  // @@protoc_insertion_point(field_get:objectstore.ErrorResponse.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorResponse::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:objectstore.ErrorResponse.message)
}
inline std::string* ErrorResponse::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:objectstore.ErrorResponse.message)
  return _s;
}
inline const std::string& ErrorResponse::_internal_message() const {
  return _impl_.message_.Get();
}
inline void ErrorResponse::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorResponse::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorResponse::release_message() {
  // @@protoc_insertion_point(field_release:objectstore.ErrorResponse.message)
  return _impl_.message_.Release();
}
inline void ErrorResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:objectstore.ErrorResponse.message)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace objectstore

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::objectstore::FieldType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::objectstore::FieldType>() {
  return ::objectstore::FieldType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_definition_2eproto
